<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ITS AI 認證練習</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        html { scrollbar-gutter: stable; }
        body { background-color: #f8f9fa; font-family: "Microsoft JhengHei", "Segoe UI", sans-serif; overflow-x: hidden !important; }
        .main-wrapper { display: flex; min-height: 100vh; }
        .sidebar { width: 280px; background: #fff; border-right: 1px solid #dee2e6; display: flex; flex-direction: column; position: fixed; top: 0; bottom: 0; left: 0; z-index: 1000; transition: transform 0.3s ease; height: 100vh; }
        .sidebar-header { background: #212529; color: #fff; padding: 15px; border-bottom: 1px solid #dee2e6; flex-shrink: 0; }
        .sidebar-header h5 { font-size: 1.25rem; font-weight: bold; color: #fff; margin-bottom: 0; }
        #progress-stats { font-size: 1.2rem; font-weight: bold; color: #fff; }
        .sidebar-content { flex: 1; overflow-y: auto !important; padding: 15px; }
        .sidebar-footer { padding: 15px; border-top: 1px solid #dee2e6; background: #f8f9fa; flex-shrink: 0; }
        .content-area { flex: 1; margin-left: 280px; padding: 0; transition: margin-left 0.3s ease; overflow-x: hidden !important; }
        
        /* 預設題目與程式碼樣式 */
        code:not([class*="language-"]) { 
            display: inline-block; 
            margin: 5px 0; 
            line-height: 1.4; 
            font-size: 1.0rem; 
            color: #222222; 
        }
        code { background-color: transparent !important; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; }
        code[class*="language-"] { color: inherit; }

        .form-check-input { border-radius: 50% !important; width: 1.2rem; height: 1.2rem; background-image: none !important; cursor: pointer; }
        .form-check-input:checked { background-color: #0d6efd !important; border-color: #0d6efd !important; }
        .option-item { border: 1px solid #e9ecef; border-radius: 6px; padding: 10px; margin-bottom: 8px; cursor: pointer; transition: 0.2s; display: flex; align-items: flex-start; gap: 8px; }
        .option-item pre { margin: 0; display: inline-block; width: 100%; }
        .option-item.correct, .sub-opt-container.correct { background-color: #d1e7dd !important; border-color: #badbcc !important; color: #0f5132 !important; }
        .option-item.incorrect, .sub-opt-container.incorrect { background-color: #f8d7da !important; border-color: #f5c2c7 !important; color: #842029 !important; }
        .sub-opt-container.selected { background-color: #e7f1ff !important; border-color: #9ec5fe !important; }
        .q-node { aspect-ratio: 1; display: flex; align-items: center; justify-content: center; border: 1px solid #dee2e6; border-radius: 6px; background-color: #fff; cursor: pointer; font-size: 0.85rem; }
        .q-node.correct { background-color: #d1e7dd; color: #0f5132; }
        .q-node.incorrect { background-color: #f8d7da; color: #842029; }
        .q-node.corrected { background-color: #fd7e14; color: #fff; }
        .q-node.active { background-color: #0d6efd; color: white; transform: scale(1.1); z-index: 1; }
        .progress-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; }
        .category-tag { font-size: 0.8rem; color: #6c757d; background-color: #f8f9fa; padding: 2px 8px; border-radius: 12px; border: 1px solid #dee2e6; margin-top: 5px; display: inline-block; }
        .type-badge { font-size: 0.75rem; vertical-align: middle; }
        .question-card { border: none; box-shadow: 0 4px 15px rgba(0,0,0,0.05); background: #fff; border-radius: 8px; }
        .question-header { border-bottom: 2px solid #0d6efd; padding: 15px 20px; font-weight: bold; color: #0d6efd; display: flex; justify-content: space-between; align-items: center; }
        .question-body { padding: 20px; font-size: 1.0rem; word-wrap: break-word; word-break: normal; overflow-x: hidden; line-height: 1.8; }
        .answer-section { display: none; margin-top: 20px; padding: 20px; background: #fff; border: 2px solid #0d6efd; border-radius: 8px; }
        .explanation, .explanation pre, .explanation code, .review-exp-box pre, .review-exp-box code, pre[class*="language-"], code[class*="language-"] { white-space: pre-wrap !important; word-wrap: break-word !important; word-break: break-all !important; overflow-wrap: anywhere !important; }
        .review-item { margin-bottom: 10px; padding: 0; border: none; background: white; page-break-inside: auto; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .review-q-text { display: flex; align-items: flex-start; font-size: 1.0rem; line-height: 1.8; margin-bottom: 5px; color: #333; }
        .review-q-text b { margin-right: 8px; white-space: nowrap; }
        .review-q-text .q-content { flex: 1; }
        .review-q-text .q-content pre, .review-q-text .q-content code { margin-top: 0 !important; padding-top: 0 !important; }
        .q-img { max-width: 48%; height: auto; border-radius: 4px; box-shadow: 0 1px 4px rgba(0,0,0,0.1); margin: 5px 5px 5px 0; display: inline-block; vertical-align: top; }
        #review-area { display: none; text-align: left; padding: 20px; background: white; }
        .review-item { margin-bottom: 10px; padding: 0; border: none; background: white; page-break-inside: auto; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .review-q-text { font-size: 1.0rem; line-height: 1.8; margin-bottom: 5px; color: #333; }
        .review-ans { color: #198754; font-weight: bold; padding: 10px 15px; margin: 5px 0; border-left: 5px solid #198754; background: white; font-size: 1.0rem; }
        .review-exp-box { background: #f8f9fa; padding: 15px; border-radius: 10px; border: 1px solid #eeeeee; line-height: 1.8; color: #333; font-size: 1.0rem; }
        @media print {
            @page { size: auto; margin: 8mm !important; }
            * { box-sizing: border-box !important; -webkit-print-color-adjust: exact; overflow: visible !important; }
            html, body { margin: 0 !important; padding: 0 !important; width: 100% !important; background: white !important; font-size: 1.0rem !important; line-height: 1.8 !important; }
            .main-wrapper, .mobile-toggle, .side-nav-btn, .no-print, .sidebar { display: none !important; }
            .content-area { margin-left: 0 !important; padding: 0 !important; margin-top: 0 !important; }
            #review-area { display: block !important; width: 100% !important; padding: 0 !important; margin: 0 !important; }
            .review-item { border-bottom: 1px solid #eee !important; width: 100% !important; page-break-inside: auto; margin: 0 0 10px 0 !important; padding: 0 !important; border-top: none !important; border-left: none !important; border-right: none !important; }
            .review-q-text { padding: 10px 2px !important; font-size: 1.0rem !important; white-space: pre-wrap !important; word-break: break-all !important; width: calc(100% - 2px) !important; }
            .review-opt-line { padding-left: 2px !important; margin-bottom: 2px !important; white-space: pre-wrap !important; word-break: break-all !important; width: calc(100% - 2px) !important; }
            .review-ans { color: #198754 !important; font-weight: bold !important; padding: 8px 5px !important; border-left: 5px solid #198754 !important; margin: 5px 0 !important; white-space: pre-wrap !important; word-break: break-all !important; width: calc(100% - 2px) !important; font-size: 1.0rem !important; }
            .review-exp-box { font-size: 1.0rem !important; padding: 10px !important; border-radius: 10px !important; border: 1px solid #eee !important; margin: 0 !important; white-space: pre-wrap !important; word-break: break-all !important; background: #fafafa !important; width: calc(100% - 2px) !important; }
            pre, code { white-space: pre-wrap !important; word-break: break-all !important; border: none !important; font-size: 1.0rem !important; margin: 0 !important; padding: 0 !important; }
            .q-img { max-width: 300px !important; margin: 10px 0 !important; }
            h1 { font-size: 1.5rem !important; margin-bottom: 20px !important; }
            .q-table, table { font-size: 0.7rem !important; max-width: 98% !important; margin: 10px 0 !important; page-break-inside: avoid; -webkit-print-color-adjust: exact; border-collapse: collapse !important; box-sizing: border-box !important; }
            .q-table td, .q-table th, td, th { border: 1px solid #000 !important; padding: 6px !important; word-break: break-all !important; overflow-wrap: break-word !important; }
            .category-title, .header-bg { -webkit-print-color-adjust: exact; background-color: #f0f0f0 !important; }
        }
        .side-nav-btn { position: fixed; top: 55%; width: 25px; height: 65px; background: rgba(108, 117, 125, 0.7); color: white; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 2000; transition: left 0.3s ease, background 0.3s, width 0.2s; text-decoration: none; font-size: 1.1rem; border: none; box-shadow: none; outline: none !important; user-select: none; -webkit-tap-highlight-color: transparent; font-family: serif; font-weight: bold; transform: translateY(-50%); }
        .side-nav-btn:hover { background: #0d6efd; color: white; width: 30px; }
        .side-nav-prev { left: 280px; border-radius: 0 15px 15px 0; }
        .side-nav-next { right: 0; border-radius: 15px 0 0 15px; }
        @media (max-width: 992px) {
            .sidebar { transform: translateX(-100%); }
            .sidebar.active { transform: translateX(0); }
            .content-area { margin-left: 0; }
            .mobile-toggle { display: block !important; }
            .side-nav-btn { width: 22px; height: 50px; font-size: 0.9rem; background: rgba(33, 37, 41, 0.6); }
            .side-nav-btn.side-nav-prev { left: 0; border-radius: 0 15px 15px 0; }
            .sidebar.active ~ .side-nav-btn.side-nav-prev { left: 280px !important; }
        }
        .mobile-toggle { display: none; position: fixed; bottom: 20px; right: 20px; z-index: 1100; width: 50px; height: 50px; border-radius: 50%; background: #212529; color: white; border: none; }
        pre { background-color: transparent !important; border: none !important; line-height: 1.6; white-space: pre-wrap !important; word-wrap: break-word !important; word-break: break-all !important; overflow-x: hidden !important; margin: 0 !important; padding: 0 !important; }

        /* 表格樣式：黑色實線邊框 */
        table, .q-table { max-width: 98% !important; border-collapse: collapse !important; margin: 15px 0; border: 1px solid #000 !important; font-size: 0.9rem; line-height: 1.2; box-sizing: border-box !important; }
        th, td, .q-table th, .q-table td { border: 1px solid #000 !important; padding: 10px 8px; vertical-align: top; word-break: break-all !important; color: #000; overflow-wrap: break-word !important; }
        .w-5 { width: 5% !important; }
        .w-10 { width: 10% !important; }
        .w-15 { width: 15% !important; }
        .w-20 { width: 20% !important; }
        .w-25 { width: 25% !important; }
        .w-30 { width: 30% !important; }
        .w-35 { width: 35% !important; }
        .w-40 { width: 40% !important; }
        .w-45 { width: 45% !important; }
        .w-50 { width: 50% !important; }
        .w-60 { width: 60% !important; }
        .w-70 { width: 70% !important; }
        .w-75 { width: 75% !important; }
        .w-80 { width: 80% !important; }
        
        /* 表格對齊輔助類別 */
        .t-left { margin-left: 0 !important; margin-right: auto !important; }
        .t-center { margin-left: auto !important; margin-right: auto !important; }
        .t-right { margin-left: auto !important; margin-right: 0 !important; }
    </style>
</head>
<body>
<div class="main-wrapper">
    <nav class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="d-flex align-items-center justify-content-between mb-2">
                <div class="d-flex align-items-center"><a href="../index.html" class="text-decoration-none text-white me-2">🏠</a><h5 class="m-0" style="font-size: 1.1rem;">題庫列表</h5></div>
                <div class="d-flex gap-1">
                    <button type="button" onclick="prepareAndPrint()" class="btn btn-outline-light btn-sm py-1 px-2" style="font-size: 0.8rem;">完整解析</button>
                    <button type="button" onclick="prepareAndPrint(true)" class="btn btn-warning btn-sm py-1 px-2" style="font-size: 0.8rem; font-weight: bold;">錯題訂正</button>
                </div>
            </div>
            <div id="progress-stats">✅0 ❌0 🟠0 / 114</div>
        </div>
        <div class="sidebar-content">
            <div class="d-flex justify-content-between small mb-3 text-muted">
                <span><span style="display:inline-block;width:10px;height:10px;background:#fff;border:1px solid #ccc"></span> 未答</span>
                <span><span style="display:inline-block;width:10px;height:10px;background:#d1e7dd"></span> 正確</span>
                <span><span style="display:inline-block;width:10px;height:10px;background:#f8d7da"></span> 錯誤</span>
                <span><span style="display:inline-block;width:10px;height:10px;background:#fd7e14"></span> 已訂正</span>
            </div>
            <div class="progress-grid" id="progress-grid"></div>
        </div>
        <div class="sidebar-footer"><button class="btn btn-outline-danger btn-sm w-100" onclick="resetProgress()">重置 練習進度</button></div>
    </nav>
    <button class="mobile-toggle" onclick="toggleSidebar()">☰</button>
    <div class="side-nav-btn side-nav-prev" id="side-btn-prev" onclick="prevQuestion()">&#10094;</div>
    <div class="side-nav-btn side-nav-next" id="side-btn-next" onclick="nextQuestion()">&#10095;</div>
    <main class="content-area"><div class="container-fluid" style="width: calc(100% - 50px); padding: 0; margin-left: auto; margin-right: auto;"><div id="question-container"></div></div></main>
</div>
<div id="review-area"></div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
<script>
    const quizData = [
  {
    "id": 1,
    "type": "single",
    "question": [
      "<pre><code>1. 您需要為醫療技術人員建立一套容易解釋的導引系統。請問您應該使用哪種機器學習模型?</code></pre>"
    ],
    "options": [
      "<code>決策樹</code>",
      "<code>支援向量機</code>",
      "<code>神經網路</code>",
      "<code>K-Means叢集</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 決策樹模型：以其直觀的樹狀結構著稱，每一步決策都有清晰的路徑和條件，因此具有良好的可解釋性，適合需要向非技術人員（如醫療技術人員）解釋模型決策過程的場景。",
      "● 支援向量機和神經網路：通常被視為黑箱模型，解釋性較差。",
      "● K-Means：是無監督學習的叢集演演算法，不適用於建立導引系統（通常是分類或回歸問題）。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 2,
    "type": "single",
    "question": [
      "<pre><code>2. 您想將視覺資訊編碼成機器視覺系統能夠解譯的形式,但記憶體需求和模型大小都有限制。請問在相同的解析度下,下列哪種像資料所需的磁碟使用量最小?</code></pre>"
    ],
    "options": [
      "<code>單色</code>",
      "<code>灰階</code>",
      "<code>256色</code>",
      "<code>高動態範圍</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 單色影象：每個畫素只需要1位元來表示（例如黑或白），因此在相同解析度下，其所需的磁碟使用量最小。",
      "● 灰階影象：通常每個畫素用8位元。",
      "● 256色影象：每個畫素也用8位元（但有調色盤）。",
      "● 高動態範圍(HDR)影象：則需要更多的位元來表示更寬廣的亮度範圍，因此儲存空間需求更大。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 3,
    "type": "single",
    "question": [
      "<pre><code>3. 請將選項中各個資料集片段,填入會用到該片段的AI建模步驟:「訓練和建模」</code></pre>"
    ],
    "options": [
      "<code>訓練資料集</code>",
      "<code>驗證資料集</code>",
      "<code>測試資料集</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● AI模型的「訓練和建模」階段，顧名思義，是使用「訓練資料集」來學習資料中的模式和關係，並建立模型引數。",
      "● 驗證資料集用於調整模型超引數和防止過度擬合。",
      "● 測試資料集用於最終評估模型在未見資料上的表現。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 4,
    "type": "single",
    "question": [
      "<pre><code>4. 請將選項中各個資料集片段,填入會用到該片段的AI建模步驟:「在新審例上評估模型」</code></pre>"
    ],
    "options": [
      "<code>訓練資料集</code>",
      "<code>驗證資料集</code>",
      "<code>測試資料集</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "C"
    ],
    "weight": 5,
    "image": null,
    "explanation": [
      "<pre><code>● 「在新審例上評估模型」指的是評估模型在從未見過的全新資料上的泛化能力。",
      "● 這個階段使用的是「測試資料集」，它在整個模型訓練和調整過程中都未被模型看見，因此能提供一個客觀的模型效能評估。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 5,
    "type": "single",
    "question": [
      "<pre><code>5. 請將選項中各個資料集片段,填入會用到該片段的AI建模步驟:「訓練超引數」</code></pre>"
    ],
    "options": [
      "<code>訓練資料集</code>",
      "<code>驗證資料集</code>",
      "<code>測試資料集</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "B"
    ],
    "weight": 3,
    "image": null,
    "explanation": [
      "<pre><code>● 「訓練超引數」（或稱為模型選擇、超引數調優）的過程是使用「驗證資料集」。",
      "● 模型在訓練資料集上訓練後，會在驗證資料集上評估不同超引數組合的效能，以選擇最佳的超引數設定，避免模型對訓練資料過度擬合。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 6,
    "type": "single",
    "question": [
      "<pre><code>6. 決策樹如何訓練分類模型?</code></pre>"
    ],
    "options": [
      "<code>決策樹會在自變數和應變數之間找出線性關係,以便將資料集區分為兩個以上各自具備相似特徵的群組。</code>",
      "<code>決策樹會使用特徵將資料集區分為兩個以上各自具備相似特徵的群組。</code>",
      "<code>決策樹會找出一或多條線,用於將資料集區分為兩個以上各自具備相似特徵的群組。</code>",
      "<code>決策樹會根據資料點的特徵計算其間的相似之處,以便將資料點區分為兩個以上各自具備相似特徵的群組。</code>"
    ],
    "answer": [
      "B"
    ],
    "weight": 3,
    "image": null,
    "explanation": [
      "<pre><code>● 決策樹透過一系列基於特徵的判斷（問題）來遞迴地將資料集分割成越來越小的子集，直到每個子集中的樣本都屬於同一類別或達到停止條件。",
      "● 這個過程是基於特徵進行劃分，以最大化資訊增益或最小化不純度，從而將資料分為具有相似特徵的群組。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 7,
    "type": "single",
    "question": [
      "<pre><code>7. 下列哪個應用程式實作時並未使用 AI?</code></pre>"
    ],
    "options": [
      "<code>電子郵件自動完成功能。</code>",
      "<code>預測型瀏覽器搜尋列。</code>",
      "<code>傳訊平臺的文字轉表情圖示程式。</code>",
      "<code>電子郵件垃圾郵件篩選器。</code>"
    ],
    "answer": [
      "C"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 電子郵件自動完成：通常使用語言模型（AI）。",
      "● 預測型搜尋列：使用歷史資料和機器學習來預測使用者意圖（AI）。",
      "● 垃圾郵件篩選器：是典型的機器學習分類應用（AI）。",
      "● 傳訊平臺的文字轉表情圖示程式：如果只是簡單的關鍵字替換或預設的表情符號列表，則不一定使用AI。雖然更高階的系統可能使用NLP來理解上下文並推薦表情，但基礎功能可以不依賴AI。題目問的是「並未使用AI」，故本選項是最有可能不使用AI的。</code></pre>"
    ],
    "category": "D3_AI演算法與模型訓練"
  },
  {
    "id": 8,
    "type": "single",
    "question": [
      "<pre><code>8. 一間汽車經銷公司想根據先前的銷售資料,使用AI預測任何指定日期的來客數,以便運用這項資料制定每週計畫。對這間經銷公司而言,最重要的AI模型成功指標是什麼?</code></pre>"
    ],
    "options": [
      "<code>產生的預測結果可協助經銷公司管理庫存及安排值班員工,進而增加獲利。</code>",
      "<code>每天的預測結果差異越小越好。</code>",
      "<code>模型能夠有效率地即時執行。</code>",
      "<code>模型可以每週更新。</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● AI模型的最終目標是為業務帶來價值。",
      "● 雖然預測的準確性、執行效率和模型更新頻率都很重要，但最重要的成功指標是模型是否能實際幫助公司達成其業務目標，例如在本例中，透過最佳化庫存和人力安排來增加獲利。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 9,
    "type": "single",
    "question": [
      "<pre><code>9. 一間保險公司會根據客戶對於10個是非題的答案判斷他們是否符合折扣資格;公司的CEO想要制定一項用於判斷客戶優惠資格的計畫,代替保險代理人詢問這些問題。這項計畫必須盡可能達到快速可靠的成效,CEO詢問針對這種情形,您會推薦使用哪種AI。請問您該如何回答這位CEO?</code></pre>"
    ],
    "options": [
      "<code>在這種情況下,AI並非效率最高的解決方案因為這個問題只需使用少數決策陳述式就能處理妥當。</code>",
      "<code>叢集演演算法能將答案類似的客觀分入同一折扣群組,因此是最佳解決方案。</code>",
      "<code>神經網路能根據客戶對問題的答案學會預測對方的保險折扣獲取資格,因此是最佳解決方案。</code>",
      "<code>由於所有折扣類別都已經有充足的代表性訓練資料,因此無論使用哪種機器學習演演算法,都能快速學會正確的折扣類別。</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 僅有10個是非題，且規則可能相對簡單，使用傳統的條件判斷（決策陳述式，如if-else）可能更直接、高效且易於維護，不一定需要複雜的AI模型。",
      "● AI適用於模式複雜、資料量大或規則難以明確定義的問題。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 10,
    "type": "single",
    "question": [
      "<pre><code>10. 哪種人工智慧演演算法或應用程式會使用未標記資料?</code></pre>"
    ],
    "options": [
      "<code>叢集</code>",
      "<code>物件偵測</code>",
      "<code>分類</code>",
      "<code>機器翻譯</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 叢集（Clustering）是一種典型的非監督式學習方法，其目的是在未標記的資料中找出固有的群組或結構，因此不需要預先標記的資料。",
      "● 物件偵測、分類和機器翻譯通常屬於監督式學習（需要標記資料）或半監督式學習的範疇。</code></pre>"
    ],
    "category": "D3_AI演算法與模型訓練"
  },
  {
    "id": 11,
    "type": "single",
    "question": [
      "<pre><code>11. 一間銀行希望能偵測出詐騙交易。這間銀行能夠收集每筆交易的資料,例如金額、購買的品項。請問這屬於哪種機器學習問題?</code></pre>"
    ],
    "options": [
      "<code>監督式學習、分類</code>",
      "<code>增強式學習、遊戲</code>",
      "<code>監督式學習、迴歸</code>",
      "<code>非監督式學習、叢集</code>"
    ],
    "answer": [
      "D"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 如果銀行沒有歷史標記的詐騙交易資料，而是希望從大量交易資料中找出異常模式或群組，這可以被視為一個非監督式學習的異常檢測問題。",
      "● 而叢集是其中一種方法，將正常交易和異常交易（可能為詐騙）分到不同的群組。",
      "",
      "解題分析：",
      "● 如果答案是監督式學習、分類： 如果銀行有歷史交易資料，並且每筆交易都被標記為「詐騙」或「非詐騙」，那麼這就是一個典型的監督式學習中的分類問題，目標是訓練一個模型來區分這兩類交易。",
      "● 在實際應用中，詐騙檢測通常會使用監督式學習（如果標籤可用）或異常檢測（可以是非監督式或半監督式）。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 12,
    "type": "single",
    "question": [
      "<pre><code>12. 您和團隊成員在開發一款能在電動遊戲中作為對手的產品。團隊根據獎勵使用演演算法,也就是假如產品表現越佳,成果品質越優異。請問這屬於哪一種機器學習?</code></pre>"
    ],
    "options": [
      "<code>增強式學習</code>",
      "<code>監督式學習</code>",
      "<code>半監督式學習</code>",
      "<code>非監督式學習</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 3,
    "image": null,
    "explanation": [
      "<pre><code>● 增強式學習的核心思想是讓智慧體（agent）在環境中透過試錯來學習，並根據其行為獲得的獎勵或懲罰來調整策略，以最大化長期獎勵。",
      "● 遊戲AI是增強式學習的典型應用場景。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 13,
    "type": "single",
    "question": [
      "<pre><code>13. 與您敵對或不懷好意的有心人士可能透過惡意探索哪方面的問題以攻擊或暗中破壞 AI系統?</code></pre>"
    ],
    "options": [
      "<code>資料擷取</code>",
      "<code>過度擬合</code>",
      "<code>資料偏斜</code>",
      "<code>非監督式學習</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 惡意探索資料擷取（Data Poisoning 或 Adversarial Attacks on Training Data）是指攻擊者透過向訓練資料中注入惡意樣本來操縱或破壞AI模型的學習過程和最終效能。",
      "● 過度擬合和資料偏斜是模型自身的問題，非監督學習是一種學習正規化。</code></pre>"
    ],
    "category": "D3_AI演算法與模型訓練"
  },
  {
    "id": 14,
    "type": "single",
    "question": [
      "<pre><code>14. 為什麼AI專案團隊裡必須有不具備技術專業知識的領域專家?</code></pre>"
    ],
    "options": [
      "<code>為了將特定領域資料加入演演算法,使AI系統客觀有效率</code>",
      "<code>為了整理和清除自訂AI解決方案中的結構化及非結構化資料</code>",
      "<code>為了評估將AI整合至現有應用程式的工具</code>",
      "<code>為了訓練他們的應用AI與資料工程的技能</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 領域專家（Domain Experts）擁有特定行業或問題領域的深入知識和經驗，他們能夠幫助AI團隊理解資料的含義、識別重要的特徵、定義有意義的目標，並評估模型的實際效用和潛在偏差，從而確保AI系統的客觀性和有效性。",
      "● 整理和清除自訂AI解決方案中的結構化及非結構化資料：更偏向資料工程師的工作。",
      "● 評估將AI整合至現有應用程式的工具：更偏向技術評估。",
      "● 訓練他們的應用AI與資料工程的技能：是培訓。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 15,
    "type": "single",
    "question": [
      "<pre><code>15. 貴組織正在針對特定用途開發一套AI系統,但這套系統也能輕易用於其他用途。請問具備多種潛在用途的系統為什麼會產生道德疑慮?</code></pre>"
    ],
    "options": [
      "<code>因為可能遭人用於未經授權的用途</code>",
      "<code>因為會導致系統更容易故障</code>",
      "<code>因為可能會開拓新市場商機</code>",
      "<code>因為其他組織可能會想購買這套AI系統</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 雙重用途（Dual-use）技術是指那些既可以民用也可以軍用，或者既可以有益也可以有害的技術。",
      "● AI系統如果設計用途單一，很容易被挪用於其他未經授權或具有潛在危害的用途（例如監控、歧視），就會引發道德和倫理上的擔憂。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 16,
    "type": "single",
    "question": [
      "<pre><code>16. 數間公司共同建立並監視一個特定產業的AI相關安全性事件資料庫,希望藉由共享資訊,讓業部署的AI系統更安全。請問哪一位專案團隊成員應負責監視 AI事件資料庫中的事件?</code></pre>"
    ],
    "options": [
      "<code>負責評估團隊開發中新功能的產品經理</code>",
      "<code>負責評估成本超支和時程延遲的專案經理</code>",
      "<code>根據要求編寫高效簡潔程式碼的開發人員</code>",
      "<code>負責改良產品軟體外觀及風格的UI設計師</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 產品經理（Product Manager）通常負責產品的整體策略、功能定義和市場表現、監視行業內的AI安全事件、瞭解潛在風險和最佳實踐等，對於評估新功能、確保產品安全性和符合行業標準至關重要。",
      "● 其他角色各有其專注領域。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 17,
    "type": "single",
    "question": [
      "<pre><code>17. 一位學校諮商師想瞭解招生嚴格的明星大學主要的錄取標準,他應該使用哪種資料才能訓練出成效最佳的機器學習模型?</code></pre>"
    ],
    "options": [
      "<code>盡可能收集多個地點的各間學校在過去幾年的資料</code>",
      "<code>對自家學校收集盡可能久遠的資料</code>",
      "<code>對該學校所在的城市收集盡可能久遠的資料</code>",
      "<code>收集該學校過去十年的資料</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 為了訓練一個能夠泛化並理解「明星大學」錄取標準的模型，需要多樣化且具代表性的資料。",
      "● 僅僅收集自家學校或單一城市學校的資料可能導致模型偏頗或無法捕捉到更廣泛的錄取模式。",
      "● 收集「多個地點的各間學校」在「過去幾年」的資料，可以提供更豐富的特徵和多樣性，有助於建立更穩健和準確的模型。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 18,
    "type": "single",
    "question": [
      "<pre><code>18. 一間公司提供使用者非常多種類的產品;他們想將產品整理成不同組別,以便針對每組產品分別制定行銷策略。請問這屬於哪種機器學習問題?</code></pre>"
    ],
    "options": [
      "<code>監督式學習、叢集</code>",
      "<code>監督式學習、迴歸</code>",
      "<code>非監督式學習、分類</code>",
      "<code>非監督式學習、叢集</code>"
    ],
    "answer": [
      "D"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 題目描述的是將產品「整理成不同組別」，而沒有預先定義好的組別標籤。",
      "● 這種根據資料本身的相似性將其分組的任務屬於非監督式學習中的叢集（Clustering）問題。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 19,
    "type": "single",
    "question": [
      "<pre><code>19. 您的團隊正在打造一個農業機器人,這個機器人會使用視覺系統辨識雜草,然後以不傷害到周圍作物的方式清除雜草。您的任務是為這項專案開發一個訓練資料集。請問這個訓練集中應加入哪些影象?為什麼?</code></pre>"
    ],
    "options": [
      "<code>雜草和作物的影象,這樣系統才能學習如何分辨可能看到的兩種植物類別</code>",
      "<code>各式型別的影象,這樣機器人才能在各種不同環境中進行一般物件辨識</code>",
      "<code>只需加入雜草的影象,這樣系統便能建立專為辨識雜草而調整的健全辨識模型</code>",
      "<code>在農場上能看到的所有物件的影象,包含工具、家畜、作物等,這樣機器人才能辨識在自己工作的農場上可能遇到的所有物件</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 為了讓機器人能夠準確「辨識雜草」並「不傷害到周圍作物」，訓練資料集必須包含這兩類主要的視覺目標：雜草和作物。",
      "● 這樣模型才能學習區分它們的特徵。",
      "● 各式型別的影象選項：過於泛化。",
      "● 只需加入雜草的影象選項：忽略了區分作物的重要性。",
      "● 農場上能看到的所有物件的影象選項：雖然包含作物和雜草，但可能引入過多不相關的物件，增加模型複雜度和訓練難度，除非這些物件也需要被識別。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 20,
    "type": "single",
    "question": [
      "<pre><code>20. 一間公司開發了一款智慧型手機用程式,可使用GPS 與加速計資料辨識並回報城市街道上的路面坑洞。他們原先的目的是協助為數千個需要填補的路面坑洞分配資源,但城裡許多老年人和低收入居民都沒有智慧型手機,因此導致資料集產生偏差,僅有富裕的社群受益。請問這是哪種偏差型別的例子?</code></pre>"
    ],
    "options": [
      "<code>自動化偏差</code>",
      "<code>資料收集偏差</code>",
      "<code>人類認知偏差</code>",
      "<code>增強式偏差</code>"
    ],
    "answer": [
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 資料收集偏差（Data Collection Bias）或稱取樣偏差（Sampling Bias），指的是收集資料的過程未能均勻地代表目標總體，導致某些群體被過度代表或代表不足。",
      "● 在這個例子中，由於依賴智慧型手機收集資料，導致沒有智慧型手機的群體（老年人和低收入居民）的資料缺失，使得資料集偏向於擁有智慧型手機的富裕社群。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 21,
    "type": "single",
    "question": [
      "<pre><code>21. 您正在建置一個模型,想用於預測內送電子郵件是否為垃圾郵件。下表顯示了資料集的代表性範例。請問在此資料集中,有什麼問題是您必須解決的?</code></pre>"
    ],
    "options": [
      "<code>資料毀損</code>",
      "<code>資料不平衡</code>",
      "<code>資料缺失</code>",
      "<code>極端值</code>"
    ],
    "answer": [
      "B"
    ],
    "weight": 1,
    "image": "images/21.png",
    "explanation": [
      "<pre><code>● 從表格範例中（假設 [否] 是錯誤或待清理的標籤，但主要問題在於類別分佈），如果「是垃圾郵件」的樣本數量遠少於「非垃圾郵件」的樣本數量（或者反之），這就是資料不平衡（Data Imbalance）問題，這會導致模型傾向於預測多數類，而對少數類的識別能力較差。",
      "● 雖然 [否] 可能代表資料毀損或需要清理，但題目更可能指向類別不平衡的問題，這是垃圾郵件檢測中常見的挑戰。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 22,
    "type": "single",
    "question": [
      "<pre><code>23. 請將清單中各個AI問題移至最適當的資料型別:「時間序列資料」</code></pre>"
    ],
    "options": [
      "<code>各個地區的投票模式</code>",
      "<code>物件辨識</code>",
      "<code>電子郵件情感分析</code>",
      "<code>股票價格預測</code>"
    ],
    "answer": [
      "D"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 時間序列資料是指按時間順序排列的資料點。",
      "● 股票價格預測顯然是基於歷史價格隨時間變化的資料，因此屬於時間序列資料。",
      "● 投票模式可能是地理空間或人口統計資料。",
      "● 物件辨識是影象資料。",
      "● 情感分析是文字資料。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 23,
    "type": "single",
    "question": [
      "<pre><code>24. 請將清單中各個AI問題移至最適當的資料型別:「表格式資料」</code></pre>"
    ],
    "options": [
      "<code>各個地區的投票模式</code>",
      "<code>物件辨識</code>",
      "<code>電子郵件情感分析</code>",
      "<code>股票價格預測</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 表格式資料通常由行和列組成，每行代表一個樣本，每列代表一個特徵。",
      "● 各個地區的投票模式可以很容易地用表格形式表示，例如每行是一個地區，列可以是候選人得票數、人口統計特徵等。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 24,
    "type": "single",
    "question": [
      "<pre><code>25. 請將清單中各個AI問題移至最適當的資料型別:「文字資料」</code></pre>"
    ],
    "options": [
      "<code>各個地區的投票模式</code>",
      "<code>物件辨識</code>",
      "<code>電子郵件情感分析</code>",
      "<code>股票價格預測</code>"
    ],
    "answer": [
      "C"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 電子郵件情感分析直接處理電子郵件的文字內容，以判斷其情感傾向，因此屬於文字資料。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 25,
    "type": "single",
    "question": [
      "<pre><code>26. 請將清單中各個AI問題移至最適當的資料型別:「圖像資料」</code></pre>"
    ],
    "options": [
      "<code>各個地區的投票模式</code>",
      "<code>物件辨識</code>",
      "<code>電子郵件情感分析</code>",
      "<code>股票價格預測</code>"
    ],
    "answer": [
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 物件辨識是計算機視覺的核心任務之一，其輸入是影象，目標是識別影象中的物件，因此屬於影象資料。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 26,
    "type": "single",
    "question": [
      "<pre><code>27. 您正在建置一個AI,用於預測是該核准客戶的貸款申請。因為貴公司對自家客戶知之甚詳,所以您手的資料包含許多特徵,但一開始您只想使用最有價值的特徵,以便將AI的成功率提到最高。請問您該怎麼做?</code></pre>"
    ],
    "options": [
      "<code>與負責人工核准貸款的人員討論,詢問他們該考慮哪些因素</code>",
      "<code>只保留描述客戶私人情況的特徵,因為這些專案最具特色</code>",
      "<code>詢問客戶他們認為在貸款申請評估中,自己最大的優勢是什麼</code>",
      "<code>只保留數字特徵(例如客戶年齡),因為AI只會處理數字</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 領域專家（此處為負責人工核准貸款的人員）的經驗和知識對於識別哪些特徵在實際決策中更為重要非常有價值。",
      "● 他們的見解可以指導初步的特徵選擇，幫助AI模型從相關性最高的資訊開始學習。",
      "● 只保留描述客戶私人情況的特徵選項：可能引入偏見。",
      "● 詢問客戶貸款申請評估最大的優勢選項：客戶的看法可能主觀。",
      "● 只保留數字特徵選項：忽略了非數字特徵（可以透過編碼轉換）的重要性。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 27,
    "type": "single",
    "question": [
      "<pre><code>28.您有下列資料集。<br>[[image01]]<br>您必須認識到上列哪些表格使用了資料的分類限界辦識的轉換方法。<br>請問哪個表格使用了 One-Hot Encoding?</code></pre>"
    ],
    "options": [
      "<code>表格 A</code>",
      "<code>表格 B</code>",
      "<code>表格 C</code>"
    ],
    "answer": [
      "B"
    ],
    "weight": 1,
    "image": null,
    "image01": "images/28.png",
    "image02": "images/28_1.png",
    "explanation": [
      "<pre><code>1、標籤編碼 (Label Encoding)： 將每個類別映射到一個唯一的整數。例如：學士=1, 碩士=2, 博士=3。",
      "2、One-Hot Encoding (獨熱編碼 / 有效編碼)： 為每個類別創建一個新的二元特徵（欄位）。對於每個樣本，其所屬",
      "類別對應的新特徵值為 1，其他所有新特徵值為 0。如果有 k 個類別，就會產生 k 個新的二元特徵。",
      "3、虛擬編碼 (Dummy Encoding)： 與 One-Hot Encoding 類似，但只為 k 個類別創建 k-1 個新的二元特徵。其中一",
      "個類別被當作「參考類別」，由所有 k-1 個虛擬變數都為 0 來表示。這樣可以避免多重共線性的問題。",
      "[[image02]]</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 28,
    "type": "single",
    "question": [
      "<pre><code>31. 您正在製作一個模型,用於估計北極被冰層覆蓋的土地面積。您擁有10萬張具有標籤的北極圈衛星影象,可用於訓練機器學習模型區分冰層、水域、土地,以產生土地面積估計值。請問您該如何將影象配置給訓練和測試資料集?</code></pre>"
    ],
    "options": [
      "<code>將大約80%的影象用於進行訓練,剩下的用於進行測試。</code>",
      "<code>將大約50%的影象用於進行訓練,剩下的用於進行測試。</code>",
      "<code>將具有標的影象100%用於訓練及測試模型</code>",
      "<code>使用所有資料訓練模型,再用其中一部分資料進行測試</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 在機器學習中，通常會將資料集劃分為訓練集、驗證集和測試集。",
      "● 常見的劃分比例是 70-80% 用於訓練，10-15%用於驗證，10-15%用於測試。",
      "● 這裡只提到了訓練和測試，80/20的劃分是一個合理的起始點，確保有足夠的資料訓練模型，同時也保留一部分獨立的資料來評估其泛化能力。",
      "● 其它選項的做法會導致測試集與訓練集重疊，無法客觀評估模型效能。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 29,
    "type": "single",
    "question": [
      "<pre><code>33. 您建置了兩個AI,用於區分成人和兒童,各個AI的混淆矩陣如下所示。(圖片顯示兩個混淆矩陣。矩陣1：預測成人/實際成人 3, 預測兒童/實際成人 2, 預測成人/實際兒童 2, 預測兒童/實際兒童 3。準確率 = (3+3)/(3+2+2+3) = 6/10 = 60%。矩陣2：預測成人/實際成人 0, 預測兒童/實際成人 2, 預測成人/實際兒童 0, 預測兒童/實際兒童 8。準確率 = (0+8)/(0+2+0+8) = 8/10 = 80%。) 哪個AI較佳?為什麼?</code></pre>"
    ],
    "options": [
      "<code>AI1,因為正確預測成人和兒童的數值相同</code>",
      "<code>AI2,因為正確預測兒童的數值最高</code>",
      "<code>AI1,因為其準確率為60%</code>",
      "<code>AI2,因為其準確率為80%</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": "images/33.png",
    "explanation": [
      "<pre><code>●  選擇AI1的理由是「正確預測成人和兒童的數值相同」，這可能是在強調模型在各類別上的平衡性，即使整體準確率較低。",
      "● AI1對成人預測3個正確，對兒童預測3個正確。",
      "● AI2對成人預測0個正確，對兒童預測8個正確，表現非常不平衡。",
      "● 在某些應用中，平衡性可能比總體準確率更重要。</code></pre>"
    ],
    "category": "D3_AI演算法與模型訓練"
  },
  {
    "id": 30,
    "type": "multioption",
    "question": [
      "<pre><code>36. 這三個模型使用的都是同一個資料集。</code></pre>[[image01]]<pre><code>(1) 模型 1 <br>(2) 模型 2<br>(3) 模型 3<br></code></pre>"
    ],
    "options": [
      "<code>低度擬合|模型最佳|過度擬合</code>",
      "<code>低度擬合|模型最佳|過度擬合</code>",
      "<code>低度擬合|模型最佳|過度擬合</code>"
    ],
    "answer": [
      "A",
      "B",
      "C"
    ],
    "weight": 1,
    "image": null,
	"image01": "images/34.png",
    "explanation": [
      "<pre><code>(圖片顯示模型1為線性擬合，欠擬合；模型2為適當擬合；模型3為過度擬合)",
      "模型1是一條直線，未能捕捉數據的非線性趨勢，屬於低度擬合（欠擬合）。",
      "模型2在捕捉數據整體趨勢和避免過度擬合之間取得了較好的平衡，看起來是最佳的模型。",
      "模型3過於緊密地貼合了訓練數據中的每一個點，包括噪聲，這很可能導致在新的、未見過的數據上表現不佳，屬於過度擬合。",
      "過度擬合（Overfitting）：指的是模型在訓練數據上表現很好，但在未見過的測試數據上表現較差。",
      "模型3的擬合線幾乎穿過了所有的訓練數據點，這通常是過度擬合的表現，它學習了訓練數據中的噪聲和特定模式，而不是潛在的",
      "一般規律。",
      "低度擬合（Underfitting）或欠擬合：指的是模型過於簡單，未能捕捉到數據中的基本模式和趨勢。模型1用一條直",
      "線去擬合明顯具有非線性趨勢的數據點，無法很好地描述數據，是低度擬合的典型例子。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 31,
    "type": "single",
    "question": [
      "<pre><code>37. 這張圖表依據性別和年份顯示擁有銀行帳戶的人口百分比。請問這屬於哪種視覺效果? (圖片顯示男性和女性擁有銀行帳戶百分比隨年份變化的折線圖)<br>[[image01]]</code></pre>"
    ],
    "options": [
      "<code>交集</code>",
      "<code>長期變化</code>",
      "<code>對比</code>",
      "<code>因素</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 3,
    "image01": "images/37.png",
    "explanation": [
      "<pre><code>● [交集] 在此處的理解可能比較特殊。",
      "● 圖表中女性的線在2014年超過了男性的線，形成了一個視覺上的交叉點，或許這是 [交集] 的含義。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 32,
    "type": "single",
    "question": [
      "<pre><code>38. 哪種指標經常用於評估迴歸AI的品質?</code></pre>"
    ],
    "options": [
      "<code>均方根誤差(RMSE)</code>",
      "<code>準確率</code>",
      "<code>召回率</code>",
      "<code>精確率</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 均方根誤差（Root Mean Squared Error, RMSE）是評估迴歸模型預測值與實際值之間差異的常用指標。",
      "● 它衡量的是預測誤差的平均大小。",
      "● 準確率、召回率和精確率是分類問題中常用的評估指標。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 33,
    "type": "single",
    "question": [
      "<pre><code>39. 您需要對使用交易資料進行訓練的詐騙偵測模型進行成效評估。請問您應該使用哪一種指標?</code></pre>"
    ],
    "options": [
      "<code>混淆矩陣</code>",
      "<code>確判為真率</code>",
      "<code>準確率</code>",
      "<code>BLEU</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 混淆矩陣（Confusion Matrix）提供了一個詳細的分類模型效能檢視，顯示了真正例（TP）、假正例（FP）、真反例（TN）和假反例（FN）的數量。",
      "● 對於像詐騙偵測這樣類別不平衡且誤判成本不同的問題，混淆矩陣及其衍生的指標（如精確率、召回率、F1分數）比單純的準確率更能全面評估模型。",
      "● BLEU是評估機器翻譯品質的指標。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 34,
    "type": "single",
    "question": [
      "<pre><code>40. 準確率和精確率有什麼差異?</code></pre>"
    ],
    "options": [
      "<code>當資料集不平衡時,準確率比查準率更有用。</code>",
      "<code>準確率只能以0到1之間的數字表示,而查準率只能以百分比表示。</code>",
      "<code>準確率是指精確率與召回率的加權平均;精確率是指正確預測正向觀測資料佔所有預測正向觀測資料的比例。</code>",
      "<code>準確率是指測量值與「真」值之間的差距;精確率是指測量值彼此之間的差距。</code>"
    ],
    "answer": [
      "D"
    ],
    "weight": 3,
    "image": null,
    "explanation": [
      "<pre><code>● 準確率 (Accuracy) = (TP+TN)/(TP+TN+FP+FN)。",
      "● 精確率 (Precision) = TP/(TP+FP)，即正確預測為正向的樣本中，實際為正向的比例。",
      "● 準確率（Accuracy）衡量的是模型預測正確的比例，可以理解為預測值與真實值之間的接近程度。",
      "● 精確率（Precision，在科學測量中）指的是多次測量結果之間的一致性或重複性。在機器學習分類問題中，精確率（查準率）有特定定義 (TP/(TP+FP))。",
      "● 題目中的「查準率」應指機器學習中的 Precision ，正確的說法應該是： 準確率 (Accuracy) 是指所有預測中正確的比例。",
      "● 精確率 (Precision ，或稱查準率) 是指所有被預測為正例的樣本中，真正是正例的比例。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 35,
    "type": "single",
    "question": [
      "<pre><code>41. 如想避免決策樹發生過度擬合的情形,可以採取哪些做法?</code></pre>"
    ],
    "options": [
      "<code>指定樹深上限</code>",
      "<code>決定葉節點數目下限</code>",
      "<code>確認資料集呈現高度偏態</code>",
      "<code>從訓練資料集中隨機移除部分觀測資料</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 限制決策樹的深度（指定樹深上限）是一種常見的剪枝方法，可以防止樹生長得過於複雜，從而減少過度擬合。",
      "● 決定葉節點數目下限（即一個葉節點至少包含多少樣本）也是一種剪枝策略。",
      "● 隨機移除觀測資料是資料增強或噪聲注入的一種方式，不直接是避免決策樹過度擬合的標準做法，儘管減少訓練資料量有時可能間接影響。",
      "● 在給定選項中，指定樹深上限是最直接且常用的方法。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 36,
    "type": "single",
    "question": [
      "<pre><code>42. 一間學校使用AI模型協助處理入學事宜...輸入值排除申請人的收入資料,但學校發現...結果雖然實用,卻依然偏向收入較高的學生。下列何者可能是造成這種情況的原因?</code></pre>"
    ],
    "options": [
      "<code>其他特徵(例如郵遞區號、測驗分數)與收入水準相互關聯</code>",
      "<code>訓練資料集太小,無法獲得準確的結果</code>",
      "<code>AI模型的程式碼可能含有錯誤</code>",
      "<code>他們選擇的特徵集太小,因此導致過度擬合</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 即使直接移除了「收入」這個特徵，如果資料中存在其他與收入高度相關的代理特徵（proxy features），例如郵遞區號（通常反映地區富裕程度）或某些型別的測驗分數（可能與教育資源投入相關），模型仍然可能間接學習到這種偏見，這就是所謂的「隱含偏見」。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 37,
    "type": "single",
    "question": [
      "<pre><code>43. 下列哪些物件可以協助AI專案團隊管理法規合規性?</code></pre>"
    ],
    "options": [
      "<code>資料分享合約、事件記錄檔、風險登入表</code>",
      "<code>資料策略、問題記錄檔、專案計畫</code>",
      "<code>資料品質計分卡、安全性記錄檔、指令碼</code>",
      "<code>資料模型、偵錯記錄檔、變更要求</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 資料分享合約規範了資料的使用和共享，有助於遵守隱私法規。",
      "● 事件記錄檔記錄了系統的操作和決策過程，對於審計和追溯至關重要。",
      "● 風險登入表用於識別和管理與AI系統相關的潛在風險，包括合規性風險。",
      "● 上述這些檔案都有助於確保AI專案符合相關法規要求。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 38,
    "type": "single",
    "question": [
      "<pre><code>44. 貴公司建置了臉部辨識軟體,計劃部署在辦公大樓作為保安系統的一環。您負責制定訓練計畫,協助大樓保全人員瞭解如何使用這套軟體。請問您的訓練計畫應該包括哪些內容?</code></pre>"
    ],
    "options": [
      "<code>接獲AI認錯人的投訴時應採取的處理流程</code>",
      "<code>介紹軟體中使用的最新神經網路</code>",
      "<code>再次說明AI的可解釋性,讓保全人員瞭解AI為何會如此運作</code>",
      "<code>介紹測試方法,以便讓保全人員測試AI的準確率</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 對於實際操作AI系統的保全人員來說，最重要的是知道在系統出錯（如認錯人）時如何應對，以確保安全和妥善處理。",
      "● 瞭解技術細節或測試方法對他們日常操作的直接幫助較小，而處理異常情況的流程則至關重要。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 39,
    "type": "single",
    "question": [
      "<pre><code>45. 一間銀行建置了AI,用於預測客戶是否可能拖欠貨款...銀行想確實保留相關記錄,以便向客戶說明決策的方式。請問銀行應該提供下列哪項資訊以減少未來發生的爭議?</code></pre>"
    ],
    "options": [
      "<code>用於訓練AI的資料集</code>",
      "<code>編寫預測程式碼的工程師</code>",
      "<code>為了選出最佳演演算法而執行的訓練實驗次數</code>",
      "<code>AI在生產環境中所做的預測數</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 為了向客戶解釋決策方式並減少爭議，提供用於訓練AI的資料集的相關資訊（例如資料來源、特徵、潛在偏見等，而非原始資料本身以保護隱私）有助於增加透明度。",
      "● 瞭解模型是基於什麼樣的資料學習的，可以幫助客戶理解決策的基礎。",
      "● 其他選項與解釋決策方式的直接關聯性較小。",
      "● 更理想的情況是提供模型的可解釋性報告。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 40,
    "type": "single",
    "question": [
      "<pre><code>46. 下列哪個詞彙經常用於形容AI預測結果?</code></pre>"
    ],
    "options": [
      "<code>推斷 (Inference)</code>",
      "<code>超引數調整 (Hyperparameter tuning)</code>",
      "<code>K等分交叉驗證 (K-fold cross-validation)</code>",
      "<code>混淆矩陣 (Confusion matrix)</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 推斷（Inference）是指使用已經訓練好的AI模型對新的、未見過的資料進行預測或分類的過程。",
      "● 超引數調整和K等分交叉驗證是模型訓練和評估階段的技術。",
      "● 混淆矩陣是評估分類模型效能的工具。</code></pre>"
    ],
    "category": "D3_AI演算法與模型訓練"
  },
  {
    "id": 41,
    "type": "single",
    "question": [
      "<pre><code>47. 貴公司的目標是執行高度相關且隨時都有最佳效能的模型。您必須決定模型重新接受訓練的頻率...除了回饋意見的可用性和資料量以外,您進行評估時還應納入哪項重要因素?</code></pre>"
    ],
    "options": [
      "<code>在生產環境中模型效能的可見度</code>",
      "<code>實作簡易度</code>",
      "<code>週期性</code>",
      "<code>資源成本</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 要決定重新訓練的頻率，關鍵在於能夠監控和了解模型在實際生產環境中的表現。",
      "● 如果模型效能開始下降（概念漂移或資料漂移），就需要重新訓練。",
      "● 因此，「在生產環境中模型效能的可見度」是核心因素。",
      "● 實作簡易度、週期性（本身就是決策的結果而非輸入）和資源成本也是考慮因素，但效能監控是前提。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 42,
    "type": "single",
    "question": [
      "<pre><code>48. 您將訓練用於區分貓、狗、兔子的AI應用程式部署至生產環境。請問下列哪種情況是在生產環境發生模型漂移的例子?</code></pre>"
    ],
    "options": [
      "<code>模型經常收到區分老虎和猴子的要求</code>",
      "<code>模型只用於區分貓和兔子</code>",
      "<code>您之後加了一個猴子的影象,然後重新訓練 AI應用程式偵測全部四種動物</code>",
      "<code>您用更多具備不同照明條件的貓、狗、兔子的影象重新訓練AI</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 模型漂移（Model Drift）或概念漂移（Concept Drift）指的是生產環境中的資料分佈或目標變數與訓練資料之間的關係發生了變化，導致模型效能下降。",
      "● 如果模型原本訓練用於區分貓、狗、兔子，但在生產中卻經常遇到老虎和猴子（模型未見過的類別），這意味著輸入資料的特性發生了顯著變化，超出了模型的訓練範圍，屬於模型漂移，其它選項是重新訓練的行為。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 43,
    "type": "single",
    "question": [
      "<pre><code>49. 您將對網站使用者推薦產品的AI部署至生產環境後,該AI已在生產環境超過一年;上週由於資料科學家發現新的演演算法,這個AI加入了新的模型更新。請問您該如何評估新演演算法是否能比舊演演算法實現更高的業務效益?</code></pre>"
    ],
    "options": [
      "<code>等待三個月後,將新演演算法與舊演演算法的推薦產品銷售量進行比較</code>",
      "<code>檢閱資料科學家的實驗,確認他們在相同的測試案例上對新舊兩種演演算法都進行了評估</code>",
      "<code>檢視新舊兩種演演算法的程式碼,確認哪一種的錯誤比較多</code>",
      "<code>將使用舊演演算法時每年最忙碌的購物日銷售量,與第一天啟用新演演算法的銷售量進行比較</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 評估業務效益最直接的方法是比較關鍵業務指標（KPI），例如本例中的「推薦產品銷售量」，A/B測試是常用的方法，但如果無法進行嚴格的A/B測試，則在一段合理的時間（如三個月，以消除短期波動影響）後比較新舊演演算法的表現是一個可行的方法。",
      "● 檢閱資料科學家的實驗是評估模型效能而非業務效益。",
      "● 檢視新舊兩種演演算法的程式碼是關注程式碼錯誤而非效益。",
      "● 使用舊演演算法時與第一天啟用新演演算法比較時，比較的時間點和週期不具可比性。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 44,
    "type": "single",
    "question": [
      "<pre><code>50. 您的新AI系統已經順利透過測試,現在您可以開始收集實際運作指標。所有結果看來都符合預期,您希望很快就能開始全面部署系統。請問在這個階段,您應該採取什麼重要且合乎道德的步驟?</code></pre>"
    ],
    "options": [
      "<code>判斷這項技術是否會對任何族群造成不相稱的影響</code>",
      "<code>審查新技術,判斷系統是否可透過升級增添新功能</code>",
      "<code>根據試驗指標接受早期採用客戶的新系統預購訂單</code>",
      "<code>保留適當數量的伺服器執行個體,當有迫在眉睫的重大情況時即可使用</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 在全面部署AI系統之前，進行公平性和偏見評估至關重要，以確保系統不會對特定族群產生不成比例的負面影響，這是負責任AI開發的關鍵步驟。",
      "● 其他選項涉及技術升級、商業推廣或資源規劃，雖然也重要，但道德考量應優先。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 45,
    "type": "single",
    "question": [
      "<pre><code>51. 一間雜貨商店在網站上使用AI推薦顧客值得購入的產品,這個AI已經運作了好幾個月。決定是否要繼續使用這個AI時,商店應考慮下列哪項因素?</code></pre>"
    ],
    "options": [
      "<code>AI的推薦是否使顧客的採購量增加</code>",
      "<code>AI原始的準確度是否超過85%</code>",
      "<code>AI使用的是監督式還是非監督式演演算法</code>",
      "<code>AI是否使用了可解釋的演演算法</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 判斷AI系統是否值得繼續使用的核心標準是它是否能帶來實際的業務價值。",
      "● 在這個案例中，如果AI推薦能有效提升顧客的採購量（例如增加平均訂單價值、提高轉化率），那麼它就是有價值的。",
      "● 技術細節如準確度閾值、演演算法型別或可解釋性，雖然在開發和評估階段重要，但最終的商業決策應基於其對業務目標的貢獻。</code></pre>"
    ],
    "category": "D3_AI演算法與模型訓練"
  },
  {
    "id": 46,
    "type": "single",
    "question": [
      "<pre><code>52. 一間博物館收集了15年份的詳細訪客資訊,包含有時間戳記的入館和出館資訊。博物館館長想請您使用這些資料開發一個AI模型,用於判斷博物館在特定日期的特定時間有多少訪客。請問您應該給這位館長什麼建議?</code></pre>"
    ],
    "options": [
      "<code>這款應用程式不需要使用AI,因為只要直接查詢現有資料就能找到答案</code>",
      "<code>由於這些資料沒有標記,因此這款應用程式最適合使用非監督式學習模型</code>",
      "<code>由於輸出結果是數字,因此這款應用程式最適合使用迴歸模型</code>",
      "<code>由於輸入資料已有標記,因此這款應用程式最適合使用監督式學習模型</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 如果目標只是「判斷博物館在特定日期的特定時間有多少訪客」，並且已經有詳細的帶時間戳記的入館和出館資訊，那麼這很可能透過直接的資料庫查詢和計數就能實現，而不需要複雜的AI模型來進行預測。",
      "● AI更適用於預測未來訪客數或從更複雜的模式中提取洞察。</code></pre>"
    ],
    "category": "D3_AI演算法與模型訓練"
  },
  {
    "id": 47,
    "type": "single",
    "question": [
      "<pre><code>53. 一間公司想更深入瞭解客戶,藉此提高客戶滿意度。為達成這個目標,首先他們想依照客戶個人檔案和購物紀錄間的相似之處,將客戶分類。請問這屬於哪種機器學習問題?</code></pre>"
    ],
    "options": [
      "<code>增強式學習</code>",
      "<code>非監督式學習</code>",
      "<code>監督式學習</code>",
      "<code>元學習</code>"
    ],
    "answer": [
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 根據客戶個人檔案和購物記錄的「相似之處」將客戶「分類」（此處的分類更接近於分群），而沒有預先定義的類別標籤，這是非監督式學習中的叢集（Clustering）任務，旨在發現資料中自然的群組。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 48,
    "type": "single",
    "question": [
      "<pre><code>54. 下列哪個問題可以使用迴歸解決?</code></pre>"
    ],
    "options": [
      "<code>根據房屋的特色及地點決定賣方要價</code>",
      "<code>提供使用者依名次排序的推薦觀影清單</code>",
      "<code>藉由分析產品圖片,偵測裝配線上的產品是否有缺陷</code>",
      "<code>透過某人的腦部MRI掃描影象,判斷對方是否罹患疾病</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 迴歸問題的目標是預測一個連續的數值。",
      "● 根據房屋特色預測「賣方要價」（一個金額）是典型的迴歸問題。",
      "● 使用者依名次排序的推薦觀影清單是排序或推薦問題。",
      "● 分析產品圖片缺陷和腦部MRI掃描影象判斷對方是否罹患疾病是分類問題（有缺陷/無缺陷，罹患疾病/未罹患疾病）。</code></pre>"
    ],
    "category": "D3_AI演算法與模型訓練"
  },
  {
    "id": 49,
    "type": "single",
    "question": [
      "<pre><code>55. 下列哪一項AI問題屬於分類問題?</code></pre>"
    ],
    "options": [
      "<code>判斷傳送給客戶支援人員的電子郵件內容帶有正面還是負面情緒</code>",
      "<code>預測翌日開盤的股票價格</code>",
      "<code>判斷贏得棋局的最佳策略</code>",
      "<code>根據鄰近地區的類似房屋提出售屋目標價格</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 分類問題的目標是將輸入分配到預定義的類別中。",
      "● 判斷電子郵件情感是正面還是負面，是將郵件分到「正面」或「負面」這兩個類別，屬於分類問題。",
      "● 預測股票價格和鄰近地區的類似房屋售屋目標價格是迴歸問題。",
      "● 判斷贏得棋局的最佳策略是強化學習或規劃問題。</code></pre>"
    ],
    "category": "D3_AI演算法與模型訓練"
  },
  {
    "id": 50,
    "type": "single",
    "question": [
      "<pre><code>56. 您接到一份工作,內容是用AI根據氣溫、首次降雪日期、降水量等環境和氣候特徵,預測當地的年度河魚數量。請問這個案例為什麼應該使用迴歸模型?</code></pre>"
    ],
    "options": [
      "<code>因為輸出值是量化值</code>",
      "<code>因為輸出值是離散標籤</code>",
      "<code>因為輸入值可以用特徵向量表示</code>",
      "<code>因為輸出值是一組量化值</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 迴歸模型用於預測連續的數值輸出，而「年度河魚數量」是一個量化的數值，因此適合使用迴歸模型。",
      "● 輸出值是離散標籤描述的是分類問題。",
      "● 輸入值可以用特徵向量表示是大多數機器學習模型的共通點。",
      "● 「一組量化值」如果指的是多個連續輸出，則可能是多輸出迴歸。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 51,
    "type": "single",
    "question": [
      "<pre><code>58. 在哪種情況下,比起自己開發AI 解決方案,不如直接購買現成方案?</code></pre>"
    ],
    "options": [
      "<code>您已確認可購買的解決方案能有效協助貴組織達成目標</code>",
      "<code>您想取得競爭對手沒有的競爭優勢</code>",
      "<code>透過專為您的需求設計的程式提高效率,是您的首要目標</code>",
      "<code>您的長期計畫包含組成一支世界級技術隊,能夠隨著業務需求的改變以及業界的演進快速地轉變技術策略</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 如果市場上已有成熟的、經過驗證的AI解決方案能夠滿足組織的需求並幫助達成目標，那麼購買現成方案通常比自行開發更快速、成本更低、風險更小。",
      "● 其它選項描述的情況更傾向於自行開發以獲得定製化、競爭優勢或建立內部能力。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 52,
    "type": "single",
    "question": [
      "<pre><code>60. 一間銀行計畫透過實作AI,判斷哪謝客戶能以特殊低利率進行貸款。您負責規劃如何將AI投入生產環境,並為客戶做好準備。此外,您也必須確保銀行可以在系統中建立透明度。請問下列哪項活動至關重要?</code></pre>"
    ],
    "options": [
      "<code>追蹤生產環境中的AI使用的所有模型</code>",
      "<code>將所有原始程式碼釋出至共用存放庫</code>",
      "<code>確認銀行會發怖新聞稿,說明AI的用途</code>",
      "<code>確認專案經理瞭解每位工程師目前負責的詳細工作</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>下列活動至關重要",
      "● 為了建立透明度和可追溯性，追蹤生產環境中使用的所有AI模型（包括版本、訓練資料、效能指標等）是至關重要的，這有助於理解模型決策、監控模型效能、進行審計以及在出現問題時進行回溯。",
      "",
      "下列活動不一定至關重要：",
      "● 原始程式碼釋出至共用存放庫可能涉及商業機密。",
      "● 確認銀行會發怖新聞稿是公關行為，",
      "● 確認專案經理瞭解工程師詳細工作是專案管理細節，與系統透明度直接相關性較小。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 53,
    "type": "single",
    "question": [
      "<pre><code>61. 下列哪一個詞是指讓私人公司、研究機構、政府機關共享資料,以解決公共問題?</code></pre>"
    ],
    "options": [
      "<code>資料協作</code>",
      "<code>資料交換</code>",
      "<code>開放式資料</code>",
      "<code>公用資料</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 資料協作（Data Collaboration）是指不同組織（包括公私部門）共同合作，共享資料、工具或專業知識，以達成共同目標，例如解決公共問題。",
      "● 資料交換是其中的一個環節。",
      "● 開放資料是指資料公開可用。",
      "● 公用資料概念較廣泛。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 54,
    "type": "single",
    "question": [
      "<pre><code>62. 一間公司想要確認消費者對於新產品的意見,因此想在社群媒體平臺上進行情感分析,但是潛在消費者的數量非常多。請問這間公司該如何以結構化方式收集所需資料?</code></pre>"
    ],
    "options": [
      "<code>使用社群媒體平臺的API</code>",
      "<code>存取社群媒體平臺資料的實體儲存裝置</code>",
      "<code>請顧客提供使用者名稱,然後手動複製他們的時間軸</code>",
      "<code>請顧客提供使用者名稱,然後將他們的時間軸編目</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 社群媒體平臺通常提供API（應用程式介面），允許開發者以程式化的方式、結構化地存取和收集公開資料（如貼文、評論），這對於大規模資料收集和分析是最高效和規範的方式。",
      "● 存取社群媒體平臺資料的實體儲存裝置不可行。",
      "● 顧客提供使用者名稱效率低下且不適用於大量資料。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 55,
    "type": "single",
    "question": [
      "<pre><code>64. 一間大型跨國公司希望使用AI篩選求職者的履歷,以便找出最可能表現傑出的人才。他們提供您10年份的員工績效審查結果作為訓練資料。請問您應該對這項資料提出什麼疑慮?</code></pre>"
    ],
    "options": [
      "<code>使用這個資料集會延續過去的聘僱偏差</code>",
      "<code>這個資料集包含的資料量不可能足以進行有效的訓練</code>",
      "<code>從員工績效資料中不可能擷取到有用的特徵</code>",
      "<code>資料集可能缺少某些資訊,並因此影響模型的效能</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 歷史資料（如過去的聘僱和績效審查結果）可能包含了過去存在的偏見（例如性別、種族等方面的偏見）。",
      "● 如果直接使用這些帶有偏見的資料來訓練AI模型，模型很可能會學習並放大這些偏見，導致未來招聘決策的不公平。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 56,
    "type": "single",
    "question": [
      "<pre><code>69. 您必須將文字資料集轉換成機器學習模型能夠解讀的形式。請問您應該使用哪一種技術?</code></pre>"
    ],
    "options": [
      "<code>為資料集中每個唯一字詞指派一個唯一數值</code>",
      "<code>為資料集中每個唯一字詞指派多個數值</code>",
      "<code>為資料集中每個唯一字詞指派一個唯一類別值</code>",
      "<code>為資料集中每個唯一字詞指派多個類別值</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 將文字轉換為機器可讀格式的常見初步方法是詞彙表構建和索引化，即為每個唯一的詞分配一個唯一的整數ID，這是許多後續更複雜表示（如詞袋模型、TF-IDF、詞嵌入）的基礎。",
      "● 為資料集中每個唯一字詞指派多個數值描述的是詞嵌入（word embeddings）的思想，但為資料集中每個唯一字詞指派一個唯一數值是更基礎和直接的轉換方式。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 57,
    "type": "single",
    "question": [
      "<pre><code>70. 您正在建置一套系統,用於協助一間健身房判斷哪些客戶最可能取消會員資格。您取得的客戶資料中含有100多種特徵。請問您該如何有效挑選對AI而言實用的特徵?</code></pre>"
    ],
    "options": [
      "<code>詢問客服人員先前的客戶對於取消會員資格說了些什麼</code>",
      "<code>隨機選取10項特徵</code>",
      "<code>僅選擇數字特徵</code>",
      "<code>盡可能多使用與客戶私人特色相關的特徵,例如性別和種族</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 客服人員通常直接與客戶互動，瞭解客戶取消會員資格的原因，他們的經驗和洞察可以提供關於哪些客戶行為或反饋可能預示著流失風險的寶貴資訊，有助於初步篩選和理解潛在的相關特徵。",
      "● 隨機選取10項特徵太隨機。",
      "● 僅選擇數字特徵限制了特徵範圍。",
      "● 盡可能多使用與客戶私人特色相關的特徵可能引入偏見且不一定相關。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 58,
    "type": "single",
    "question": [
      "<pre><code>71. 數間公司共同建立並監視一個特定產業的AI 相關安全性事件資料庫,希望藉由共享資訊,讓業界部署的AI系統更安全。請問哪一位專案團隊成員應負責監視 AI事件資料庫中的事件?</code></pre>"
    ],
    "options": [
      "<code>負責制定風險降低措施的風險長</code>",
      "<code>負責評估成本超支和時程延遲的專案經理</code>",
      "<code>根據要求編寫高效簡潔程式碼的開發人員</code>",
      "<code>負責改良產品軟體外觀及風格的UI設計師</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 風險長（Chief Risk Officer）或類似的風險管理角色，其職責是識別、評估和管理組織面臨的各種風險，包括AI系統的安全性風險。",
      "● 監視行業內的AI安全事件資料庫，有助於他們瞭解新興威脅、漏洞和最佳實踐，從而制定有效的風險降低措施。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 59,
    "type": "single",
    "question": [
      "<pre><code>72. 為了提升準確率,在選擇特徵的階段應該移除哪一類特徵?</code></pre>"
    ],
    "options": [
      "<code>與目標沒有相互關聯的特徵</code>",
      "<code>含有多個值的特徵</code>",
      "<code>與目標具有高度關聯性的特徵</code>",
      "<code>在特徵集中未重複的特徵</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 與目標變數沒有顯著相關性的特徵（無關特徵）對模型的預測能力貢獻很小，甚至可能引入噪聲，降低模型準確性並增加複雜性。",
      "● 因此，在特徵選擇階段，移除這些無關特徵有助於提升模型效能。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 60,
    "type": "single",
    "question": [
      "<pre><code>73. 您正在建置迴歸AI,以便預測車輛價格,且會在進行特徵工程時使用一位有效編碼(one-hot encoding)。請問您必須對哪類特徵使用一位有效編碼?</code></pre>"
    ],
    "options": [
      "<code>車輛型別(卡車、轎車、或廂型車)</code>",
      "<code>每小時從0加速至100公里所需的時間</code>",
      "<code>在一般街道(非高速公路)上汽車的燃油效率</code>",
      "<code>車門數量</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 一位有效編碼（One-Hot Encoding）主要用於處理類別特徵（Categorical Features），特別是那些沒有內在順序的名目特徵（Nominal Features）。",
      "● 「車輛型別」（卡車、轎車、廂型車）是典型的名目類別特徵。",
      "● 其它選項都是數值特徵，可以直接使用或進行標準化/歸一化等處理。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 61,
    "type": "single",
    "question": [
      "<pre><code>74. 請問哪一項技術可協助減少AI模型輸入資料集的維度?</code></pre>"
    ],
    "options": [
      "<code>主成分分析</code>",
      "<code>一位有效編碼</code>",
      "<code>低抽樣</code>",
      "<code>移除有缺少值的特徵</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 主成分分析（Principal Component Analysis, PCA）是一種常用的降維技術，它透過線性變換將原始高維資料投影到一個新的低維子空間，同時盡可能保留原始資料的變異性。",
      "● 一位有效編碼通常會增加維度。",
      "● 低抽樣是處理類別不平衡的方法。",
      "● 移除有缺失值的特徵也是一種處理資料的方式，但不一定是降維的主要目的。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 62,
    "type": "single",
    "question": [
      "<pre><code>75. 您在建置一個AI模型。您應該對初始資料集採用哪一種方法?</code></pre>"
    ],
    "options": [
      "<code>20%作為測試資料,80%作為訓練資料,測試資料保持不變</code>",
      "<code>20%作為測試資料,100%作為訓練資料,測試資料保持不變</code>",
      "<code>20%作為測試資料,80%作為訓練資料,然後重複訓練數次</code>",
      "<code>20%作為測試資料,100%作為訓練資料,然後重複訓練數次</code>"
    ],
    "answer": [
      "C"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 標準的機器學習流程是將資料集劃分為訓練集、驗證集和測試集。",
      "● 常見的比例是例如70%訓練，15%驗證，15%測試，或者如選項中的80%訓練，20%測試（這裡可能隱含了驗證集從訓練集中劃分或透過交叉驗證）。",
      "● 模型在訓練集上訓練，在驗證集上調優超引數，最後在測試集上評估最終效能。",
      "● 「重複訓練數次」通常指在訓練過程中進行多個epoch的迭代，或者使用交叉驗證等技術。",
      "● 訓練過程中的「重複訓練數次」更符合實際的訓練過程。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 63,
    "type": "single",
    "question": [
      "<pre><code>76. 一間公司負責做貸款的核準決定,但一名顧客對於AI的結論有異議。為了進行稽核,必須準備下列哪種型別的檔案?</code></pre>"
    ],
    "options": [
      "<code>資料收集和取得同意的方法、責任鏈、品質及準確率評估</code>",
      "<code>資料元素的詳細屬性,例如資料型別、大小、可null性、選用性、索引等</code>",
      "<code>資料庫結構描述,用於說明資料的整理方式以及資料之間的關聯方式</code>",
      "<code>用於描述資料流程、輸入值和輸出值、儲存點、子流程的圖表</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 為了稽核和處理客戶異議，需要能夠證明決策過程的透明度、公平性和準確性的相關檔案。",
      "● 相關檔案應包括：資料是如何收集的、是否獲得了適當的同意、決策的責任歸屬（責任鏈）、資料的品質如何、以及模型的準確率是如何評估的。",
      "● 這些檔案有助於解釋決策依據並回應質疑。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 64,
    "type": "single",
    "question": [
      "<pre><code>78. 線性迴歸和邏輯迴歸有什麼差異?</code></pre>"
    ],
    "options": [
      "<code>線性迴歸會假定自變數和應變數之間的關係為線性。邏輯迴歸會假定兩種變數之間的關係為非線性</code>",
      "<code>使用一組特定自變數時,線性迴歸用於預測類別應變數。邏輯迴歸則用於預測連續應變數</code>",
      "<code>線性迴歸用於預測類別變數的值。邏輯迴歸用於預測連續變數的值</code>",
      "<code>線性迴歸適用於解決迴歸問題。邏輯迴歸適用於解決分類問題</code>"
    ],
    "answer": [
      "D"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 線性迴歸用於預測一個連續的數值輸出（迴歸問題）。",
      "● 邏輯迴歸雖然名字帶有「迴歸」，但它主要用於解決二分類或多分類問題，其輸出是屬於某個類別的機率。</code></pre>"
    ],
    "category": "D3_AI演算法與模型訓練"
  },
  {
    "id": 65,
    "type": "single",
    "question": [
      "<pre><code>83. 您想藉由發掘對比資料中蘊藏的意義,呈現正式金融帳戶的存取率,以及擁有足以負擔基本日常必需品的財產之間有何關聯。請問您的資料集必須符合哪些需求?</code></pre>"
    ],
    "options": [
      "<code>使用一個擁有大量變數的資料集,或多個類似的資料集</code>",
      "<code>具有變化細微的分層資料</code>",
      "<code>具有長期資料</code>",
      "<code>具有精細層級的資料</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 3,
    "image": null,
    "explanation": [
      "<pre><code>● 要分析不同因素（如金融帳戶存取率、財產狀況）之間的關聯，需要一個包含這些相關變數的資料集。",
      "● 擁有大量變數（特徵）或能夠整合多個相關資料集，可以提供更全面的資訊來發掘潛在的關聯性。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 66,
    "type": "single",
    "question": [
      "<pre><code>84. 模型低度擬合代表什麼意思?</code></pre>"
    ],
    "options": [
      "<code>方差低,偏差高</code>",
      "<code>方差高,偏差低</code>",
      "<code>模型與資料的無關特徵擬合</code>",
      "<code>測試集中的資料太少</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 低度擬合（Underfitting）的模型通常過於簡單，無法捕捉資料的複雜性，因此在訓練資料和測試資料上都表現不佳，這表現為高偏差（Bias），即模型的預測值系統性地偏離真實值。",
      "● 由於模型簡單，它對訓練資料的微小變動不敏感，因此方差（Variance）通常較低。",
      "● 方差高,偏差低描述的是過度擬合。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 67,
    "type": "single",
    "question": [
      "<pre><code>85. 您正在建置一個AI模型,用於辨識業餘賞鳥人士拍攝的照片中出現的各種不同鳥類。您剛訓練完模型,並讓模型對一組先前沒有看過的影象進行預測作為測試。為了計算模型的精確率,您應該採用哪種計算方式?</code></pre>"
    ],
    "options": [
      "<code>計算正確預測數佔總預測數的比例</code>",
      "<code>用正確預測數除以訓練集的數量</code>",
      "<code>計算正確預測數佔正向類別預測數的比例</code>",
      "<code>用正確預測數減去錯誤預測數</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 題目中的「精確率」如果指的是整體預測的正確程度，那麼「計算正確預測數佔總預測數的比例」是準確率（Accuracy）的定義。",
      "● 在多類別分類問題中，如果「精確率 (Precision)」指的是針對某一特定鳥類的預測有多準確，那麼應該是該鳥類被正確預測的數量 / 所有被預測為該鳥類的數量。",
      "● 鑑於選項，計算正確預測數佔總預測數的比例最符合對模型整體效能的評估。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 68,
    "type": "single",
    "question": [
      "<pre><code>88. 一個銀行組織的AI團隊實作了一個模型,用於預測交易是否涉及詐騙;結果訓練集的準確率雖然高達99.7%,測試集的準確率卻只有72.45%,請問下列哪一項解釋符合上述資訊?</code></pre>"
    ],
    "options": [
      "<code>模型在測試集的表現不佳,顯示為過度擬合</code>",
      "<code>模型在測試集的表現不佳,顯示為低度擬合</code>",
      "<code>模型在訓練集和測試集的表現都已經夠好了,測試集的準確度較低並不構成問題</code>",
      "<code>模型在測試集的表現不佳,顯示為低偏差</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 模型在訓練集上表現極好（99.7%準確率），但在未見過的測試集上表現顯著下降（72.45%準確率），這是過度擬合（Overfitting）的典型特徵。",
      "● 模型過於適應訓練資料的細節和噪聲，導致其泛化能力差。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 69,
    "type": "single",
    "question": [
      "<pre><code>89. 您是一個AI模型開發團隊的專案經理,這個AI的用途是向客戶推薦產品,不過您必須先取得專案關係人的核準,才能將AI推出給客戶。這個專案只是貴公司眾多AI專案的其中一個。請問哪些人可能會是專案關係人?</code></pre>"
    ],
    "options": [
      "<code>生產環境機器學習工程團隊</code>",
      "<code>用開放原始碼建置了類似AI的工程師</code>",
      "<code>公司的CEO</code>",
      "<code>貴公司的人力資源專家</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 專案關係人（Stakeholders）是指那些會受到專案影響或能影響專案的人。",
      "● 對於一個AI產品的推出，生產環境的機器學習工程團隊（負責部署、監控和維護模型）是直接相關的關鍵關係人。",
      "● CEO也是關係人，但工程團隊更直接涉及技術層面的批准和協作。",
      "● AI的工程師和人力資源專家的相關性較低。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 70,
    "type": "single",
    "question": [
      "<pre><code>90. 一間銀行建置了AI,用於預測哪客戶有可能關閉銀行帳戶,改到其他銀行開戶。在實際開始運用這個AI以前,銀行必須先訓練未來負責使用AI的員工,協助他們瞭解如何讓AI發揮最佳效能。請問這項訓練應該包含哪些內容?</code></pre>"
    ],
    "options": [
      "<code>這個AI能夠預測的型別,以及用於進行預測的資訊</code>",
      "<code>AI進行預測時使用的演演算法,以及用於評估AI的指標</code>",
      "<code>用於建置 AI預測管線的程式設計語言</code>",
      "<code>訓練這個AI模型使用的歷史資料量,以及模型的調整方式</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 為了讓員工有效使用AI系統，他們需要了解系統的功能（能預測什麼）、侷限性以及它是基於什麼資訊來做預測的。",
      "● 這有助於他們正確解讀AI的輸出並採取適當的行動。",
      "● 技術細節如演演算法、程式語言或訓練資料量對終端使用者而言通常不是最重要的。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 71,
    "type": "single",
    "question": [
      "<pre><code>93. 您必須決定是否要為自己兩年前開發的AI系統進行升級。請問您應該依照什麼順序完成動作? 請將所有動作按照正確的順序排列。<br>[[image01]]</code></pre>"
    ],
    "options": [
      "<code>ACBED</code>",
      "<code>CDABE</code>",
      "<code>ABCDE</code>",
      "<code>DAECB</code>"
    ],
    "answer": [
      "C"
    ],
    "weight": 1,
    "image01": "images/93.png",
    "explanation": [
      "<pre><code>一個合理的決策流程是：",
      "● A (分析現有系統的效能指標)： 瞭解當前系統的表現。",
      "● B (評估系統的效能是否夠高,足以做為繼續部署的理由)： 判斷現有系統是否仍滿足需求。",
      "● C (檢閱在這個AI系統之後開發出來的相關技術)： 探索是否有新的、更好的技術可用。",
      "● D (分析新技術的指標和功能)： 瞭解新技術的潛力。",
      "● E (將潛在新功能與現有系統進行比較)： 比較新舊方案，決定是否升級。",
      "",
      "因此，順序 ABCDE 是合理的。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 72,
    "type": "multiple",
    "question": [
      "<pre><code>94. 下列哪兩種問題可以使用決策樹演演算法解決?(請選擇2個答案)</code></pre>"
    ],
    "options": [
      "<code>分類</code>",
      "<code>回歸</code>",
      "<code>叢集</code>",
      "<code>增強式學習</code>",
      "<code>文字產生</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 3,
    "image": null,
    "explanation": [
      "<pre><code>決策樹演演算法是一種監督式學習方法，主要用於解決以下兩類問題：",
      "● 分類 (Classification)：當目標變數是類別型資料時，決策樹可以學習從輸入特徵到類別標籤的對映關係。例如，判斷一封郵件是否為垃圾郵件、識別圖片中的物體屬於哪個類別等。決策樹透過一系列的「是/否」問題（基於特徵的條件）來劃分資料，最終將樣本歸類到不同的葉節點所代表的類別。",
      "● 回歸 (Regression)：當目標變數是連續型數值時，決策樹也可以用來預測。例如，預測房價、股票價格等。在回歸樹中，葉節點通常表示該區域內樣本目標值的平均值或中位數。",
      "",
      "決策樹演演算法不解決以下問題",
      "● 叢集 (Clustering) 是典型的非監督式學習問題，旨在將未標記的資料分組，決策樹本身不直接執行叢集。",
      "● 增強式學習 (Reinforcement Learning) 是透過與環境互動並獲得獎勵或懲罰來學習策略，與決策樹的學習機制不同。",
      "● 文字產生 (Text Generation) 產生通常使用如迴圈神經網路 (RNN)、長短期記憶網路 (LSTM) 或 Transformer 等更適合序列資料的模型。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 73,
    "type": "multiple",
    "question": [
      "<pre><code>95. 一間動物醫院聘請您擔任專案經理,他們想使用機器學習技術預測透過X光找到的貓狗腫瘤中,有哪些特徵能為不同患者進行最準確的風險分類。...請問您會選擇讓下列哪兩位人員加入團隊?(請選擇2個答案。)</code></pre>"
    ],
    "options": [
      "<code>善於在掃描影象中辨識出腫瘤的動物放射醫療專家</code>",
      "<code>從事過影像分類工作的AI開發人員</code>",
      "<code>擅長照顧病弱寵物的當地寵物旅館店主</code>",
      "<code>經常在手術室和化療門診中協助進行寵物手術及照護的獸醫技師</code>",
      "<code>為該醫院提供化療藥物的製藥公司銷售代表</code>",
      "<code>負責採購及維護造影機械裝置的醫院CFO</code>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>專案目標是利用X光影像進行腫瘤風險分類，因此團隊中需要：",
      "● 1.動物放射醫療專家： 提供醫學領域知識，協助理解影像特徵、標註資料、驗證模型結果。",
      "● 2.AI開發人員： 具備影像分類經驗，負責建立、訓練和評估機器學習模型。",
      "",
      "其他選項的角色與此專案的核心技術需求關聯性較低。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 74,
    "type": "multiple",
    "question": [
      "<pre><code>96. 您正在為有特定目標的模型選擇資料集。在選擇有助於達成目標的資料集時,下列哪兩項因素可能是重要的元素?(請選擇2個答案。)</code></pre>"
    ],
    "options": [
      "<code>確認資料集的資料量足以達成目的</code>",
      "<code>缺少的元素或者有損壞的元素</code>",
      "<code>資料集元素的檔案格式,例如圖片</code>",
      "<code>資料集的釋出來源為學術實體還是商業實體</code>",
      "<code>資料集是否是透過資料集搜尋引擎找到的</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>下列兩項因素是重要的元素：",
      "● 選擇資料集時首先要確保資料量足夠，以訓練出具有良好泛化能力的模型。",
      "● 其次資料的品質非常重要，需要關注是否有缺失值或損壞的資料，因為這些會影響模型訓練和效能。",
      "",
      "下列幾項因素不是重要的元素：● 檔案格式是技術細節。",
      "● 釋出來源來源是查詢方式。",
      "● 是否是透過資料集搜尋引擎找到可能影響資料的可信度和適用性，但資料量和完整性是更基礎的考量。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 75,
    "type": "multiple",
    "question": [
      "<pre><code>97. 請將清單中的各項描述對應至資料儲存型別:「雲端儲存空間」</code></pre>"
    ],
    "options": [
      "<code>包含安裝及維護硬體的費用</code>",
      "<code>費用會隨著特定時間所需的空間大小而變動</code>",
      "<code>無須額外支付維護及升級費用</code>",
      "<code>即使沒有網際網路連線也依然能夠存取</code>"
    ],
    "answer": [
      "B",
      "C"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>雲端儲存空間的主要特點是：",
      "● 按需付費（費用通常根據實際使用的儲存空間和流量等因素動態計算）",
      "● 免維護（硬體的維護和升級由雲服務提供商負責，使用者無需額外支付）。",
      "",
      "其它選項更符合本地伺服器的特性。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 76,
    "type": "multiple",
    "question": [
      "<pre><code>98. 請將清單中的各項描述對應至資料儲存型別:「本機伺服器」</code></pre>"
    ],
    "options": [
      "<code>包含安裝及維護硬體的費用</code>",
      "<code>費用會隨著特定時間所需的空間大小而變動</code>",
      "<code>無須額外支付維護及升級費用</code>",
      "<code>即使沒有網際網路連線也依然能夠存取</code>"
    ],
    "answer": [
      "A",
      "D"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>本地伺服器的特點是：",
      "● 硬體成本（需要自行購買、安裝和維護硬體裝置，產生相應費用）",
      "● 本地存取（資料儲存在本地，即使沒有網際網路連線，只要能接入內部網路，通常也能存取）。",
      "",
      "其它選項是雲端儲存的特性。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 77,
    "type": "multiple",
    "question": [
      "<pre><code>99. 資料科學家會使用這個表格中顯示的資料預測來年客戶會透過銀行投資多少錢。",
      "請問在選擇特徵的階段,資料科學家應該移除哪兩欄資料?為什麼?(請選擇2個答案。)",
      "表格資料: 客戶_ID, 年齡, 城市, 學歷, 出生年, 薪資 (其中城市均為紐約市)<br>[[image01]]</code></pre>"
    ],
    "options": [
      "<code>「城市」,因為這一欄僅包含單一值</code>",
      "<code>「年齡」,因為使用「出生年」欄的值即可產生這一欄的值</code>",
      "<code>「學歷」,因為這一欄包含類別值</code>",
      "<code>「城市」,因為居住地點不影響投資的金額</code>",
      "<code>「薪資」,因為這一欄的值數字較大</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 1,
    "image01": "images/99.png",
    "explanation": [
      "<pre><code>● 「城市僅包含單一值」： 如果表格中所有客戶的「城市」都是「紐約市」（即單一值），那麼這個特徵對於區分客戶或預測投資金額沒有任何資訊量，應該移除。",
      "● 「年齡」： 「年齡」可以從「出生年」和當前年份計算得出，存在共線性，保留兩者之一即可，移除「年齡」以避免冗餘。",
      "● 「學歷」類別值可以透過編碼處理。",
      "●  「城市居住地點不影響投資的金額」是假設，不一定成立。",
      "● 「薪資」數值大小可以透過標準化處理。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 78,
    "type": "multiple",
    "question": [
      "<pre><code>100. 一間醫院正在打一套AI解決方案,用於預測患者是否可能取消約診。...標籍為「是」(患者下次不會到診)或「否」(患者下次會到診)。請問在進行特徵工程時,可能執行下列哪兩種作業?(請選擇2個答案。)</code></pre>"
    ],
    "options": [
      "<code>將「是」與「否」編碼為數值</code>",
      "<code>將病症編碼為數值</code>",
      "<code>為了在此資料集上進行實驗,選取最佳分類演演算法</code>",
      "<code>評估在開發AI時,是否能滿足患者的隱私權需求</code>",
      "<code>對AI演演算法進行超引數調整</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 在特徵工程階段，將「是」與「否」編碼為數值（例如 1 和 0）可以使模型更容易理解這些標籤。",
      "● 將病症編碼為數值也有助於模型處理這些類別特徵。",
      "● 選取最佳分類演演算法是模型選擇。",
      "● 滿足患者的隱私權需求是隱私考量。",
      "● 進行超引數調整是模型調優，這些不屬於特徵工程的範疇。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 79,
    "type": "multiple",
    "question": [
      "<pre><code>102. 一個AI團隊實作的模型似乎有過度擬合的情況。請問這個團隊可以採取下列哪三種方法解決問題?(請選擇3個答案。)</code></pre>"
    ],
    "options": [
      "<code>收集更多資料</code>",
      "<code>確認資料未出現不平衡的現象</code>",
      "<code>調整超引數</code>",
      "<code>實作一個更複雜的模型</code>",
      "<code>改用非線性模型</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B",
      "C"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>解決過度擬合的方法包括：",
      "● 收集更多資料： 增加訓練資料量有助於模型學習到更具泛化性的模式。",
      "● 確認資料未出現不平衡的現象： 雖然資料不平衡本身不直接導致過擬合，但處理不平衡（如重取樣）有時可以改善模型對少數類的學習，間接影響泛化。更直接的說法是進行正規化、簡化模型、特徵選擇等。",
      "● 調整超引數： 例如，對於決策樹，可以限制樹的深度。",
      "",
      "以下方法不符合：",
      "● 實作更複雜的模型通常會加劇過度擬合。",
      "● 如果原模型是線性的且欠擬合，改用非線性模型可能改善，但如果已經過擬合，則不一定有效。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 80,
    "type": "multiple",
    "question": [
      "<pre><code>103. 您建立了一個模型,並進行了測試。在實際部署之前,您決定先詢問客戶對模型的印象。在這個流程中,哪兩項必要的工作?(請選擇2個答案。)</code></pre>"
    ],
    "options": [
      "<code>根據結果進行效能評定並告知客戶潛在風險</code>",
      "<code>與客戶會面,共同評估解決方案</code>",
      "<code>擴大所使用模型的規模</code>",
      "<code>搜尋改良技術</code>",
      "<code>將自己的結果與競爭對手的結果進行比較</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>在與客戶溝通模型時，重要的是：",
      "● 效能評定與風險告知： 透明地告知客戶模型的效能表現（基於測試結果）以及使用該模型可能存在的潛在風險或侷限性。",
      "● 共同評估： 與客戶一起評估解決方案是否符合他們的期望和需求，收集他們的反饋。",
      "",
      "其它選項是模型開發或市場分析的內部工作，而非直接與客戶溝通的必要內容。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 81,
    "type": "multiple",
    "question": [
      "<pre><code>104. 一個組織靠連續管線將數量不斷增加的機器學習模型保持在最新狀態。請問生產環境AI作業中部署了下列哪兩種演演算法?(請選擇2個答案。)</code></pre>"
    ],
    "options": [
      "<code>事件票證</code>",
      "<code>不可變基礎結構模式</code>",
      "<code>AI健康情況監視</code>",
      "<code>推斷調整</code>",
      "<code>特徵存放庫</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "C",
      "D"
    ],
    "weight": 3,
    "image": null,
    "explanation": [
      "<pre><code>在生產環境中運維AI模型（MLOps）時：需部署了下列兩種演演算法",
      "● AI健康情況監視： 持續監控模型的效能指標（如準確率、延遲、漂移情況）以確保其正常運作。",
      "● 推斷調整： 可能指對推斷服務的配置進行調整以最佳化效能，或者根據監控結果觸發模型的重新訓練和更新。",
      "",
      "其它的演演算法不適合此場合：",
      "● 事件票證是IT服務管理工具。",
      "● 不可變基礎設施是部署策略。",
      "● 特徵存放庫是管理特徵的系統。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 82,
    "type": "multiple",
    "question": [
      "<pre><code>105. 您開發了一個能向使用者推薦歌曲的AI,使用者可以選取「很棒」或「很糟」按鈕,對推薦歌曲提供回饋意見。請問接收使用者回饋意見會有下列哪三項優點?(請選擇3個答案。)</code></pre>"
    ],
    "options": [
      "<code>對推薦演演算法的不同版本進行有效的A/B測試</code>",
      "<code>瞭解使用者對這套系統的滿意度</code>",
      "<code>有機會更輕易地取得使用者個人資料</code>",
      "<code>瞭解最新的技術發展</code>",
      "<code>縮減模型大小</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B",
      "C"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>使用者回饋對於推薦系統非常重要：",
      "● A/B測試： 可以將不同版本的推薦演演算法推送給不同使用者群，根據他們的回饋（如點選率、評分）來比較演演算法效果。",
      "● 使用者滿意度： 直接的回饋（如「很棒」/「很糟」）是衡量使用者對推薦結果滿意度的指標。",
      "● 取得使用者個人資料： 雖然這裡的「個人資料」可能指偏好資料而非身份資訊，",
      "但使用者的互動行為（點選、評分）確實構成了有價值的使用者偏好資料，可以用來改進個性化推薦。",
      "",
      "其它選項與使用者直接回饋的關聯性不大。</code></pre>"
    ],
    "category": "D3_AI演算法與模型訓練"
  },
  {
    "id": 83,
    "type": "multiple",
    "question": [
      "<pre><code>106. 一間公司想使用自動化作業簡化多項工作。請問下列哪三項工作適合採用AI 解決方案?(請選擇3個答案。)</code></pre>"
    ],
    "options": [
      "<code>理解檔案內容</code>",
      "<code>以視覺化方式呈現畫面(包含虛擬桌面)</code>",
      "<code>找出可自動化的工作和流程</code>",
      "<code>登入應用程式</code>",
      "<code>複製並貼上資料</code>",
      "<code>從網路上抓取資料</code>"
    ],
    "answer": [
      "A",
      "B",
      "C"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>想使用自動化作業簡化多項工作適合以下方案：",
      "● 理解檔案內容：",
      "自然語言處理（NLP）是AI的重要分支，可用於文字理解、摘要、情感分析等。",
      "● 以視覺化方式呈現畫面(包含虛擬桌面)： 計算機視覺和影象生成技術（AI）可以處理和生成視覺內容。如果指的是智慧化的視覺呈現或分析，則AI適用。",
      "● 找出可自動化的工作和流程： 流程挖掘（Process Mining）等AI技術可以分析現有流程，識別瓶頸和可自動化的環節。",
      "",
      "其它選項通常可以透過傳統的自動化指令碼或RPA（機器人流程自動化）解決，不一定需要複雜的AI。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 84,
    "type": "multiple",
    "question": [
      "<pre><code>107. 下列哪兩項專案會因為使用AI建模而受益?(請選擇2個答案。)</code></pre>"
    ],
    "options": [
      "<code>判斷會有多少收到促銷優惠電子郵件的使用者檢視公司網站</code>",
      "<code>透過社群媒體使用者的評論、主題標籤、訊息,判斷他們對於特定主題的意見</code>",
      "<code>根據銀行客戶在銀行網站上表現的行為,選取給予信用卡優惠的物件</code>",
      "<code>檢查使用者的密碼是否符合由帳戶擁有者設定的密碼</code>",
      "<code>將電子報傳送給郵寄清單上所有人</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "B",
      "C"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>下列兩項專案會因為使用AI建模而受益：",
      "● 判斷社群媒體意見： 這是情感分析或意見挖掘的典型應用，屬於自然語言處理（AI）。",
      "● 根據行為選取優惠物件： 這可以透過建立使用者畫像、預測模型（如預測哪些客戶更可能響應優惠）來實現，是機器學習的應用。",
      "",
      "下列專案不會因為使用AI建模而受益：",
      "● 判斷會有多少收到促銷優惠電子郵件的使用者檢視公司網站，可能是簡單的統計或基礎的預測。",
      "● 檢查使用者的密碼是否符合由帳戶擁有者設定的密碼是基本的驗證邏輯。",
      "● 將電子報傳送給郵寄清單上所有人是批次操作。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 85,
    "type": "multiple",
    "question": [
      "<pre><code>109. 下列哪兩種問題可以使用決策樹演算法解決?(請選擇2個答案。)<br>(1)分類<br>(2)回歸<br>(3)叢集<br>(4)增強式學習<br>(5)文字產生<br>(6)以上皆是</code></pre>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>2、3、5 (ITS答案) / 1、2 (標準答案)",
      "解題分析 (基於PDF答案2、3、5)： * (2) 回歸： 決策樹可以處理回歸問題（預測連續值）。 * (3) 叢集： 雖然決",
      "策樹主要用於監督學習，但有一些變種或與其他技術結合的方式可以間接用於或輔助叢集分析（例如，通過決策樹",
      "的葉節點來定義群組）。但它本身不是典型的叢集演算法。 * (5) 文字產生： 傳統決策樹不直接用於文字產生。文",
      "字產生通常使用基於序列的模型，如RNN、LSTM、Transformer。",
      "解題分析 (標準答案1、2)： 決策樹的核心應用是分類和回歸。PDF提供的答案(3)和(5)與決策樹的典型用途有較大",
      "差異。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 86,
    "type": "multiple",
    "question": [
      "<pre><code>110. 下列哪三種演演算法可以用於解決分類問題？（請選擇3個答案)</code></pre>"
    ],
    "options": [
      "<code>K-Means</code>",
      "<code>決策樹</code>",
      "<code>邏輯迴歸</code>",
      "<code>線性迴歸</code>",
      "<code>SVM</code>",
      "<code>主成分分析</code>"
    ],
    "answer": [
      "B",
      "C",
      "E"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>分類問題的目標是將輸入資料分配到預先定義的類別中。以下演演算法可以用於解決分類問題：",
      "● 決策樹 (Decision Tree)： 是一種監督式學習演演算法，可以透過學習資料特徵來建立樹狀模型，用於分類（預測離散類別）和回歸（預測連續值）。",
      "● 邏輯迴歸 (Logistic Regression)： 它是一種廣泛用於二元分類問題的監督式學習演演算法，也可以擴充套件到多元分類。",
      "● SVM (Support Vector Machine，支援向量機)： 是一種強大的監督式學習演演算法，常用於分類問題，也可以用於回歸。",
      "",
      "以下演演算法不可以用於解決分類問題：",
      "● K-Means：是一種非監督式學習的叢集演演算法，用於將資料分組，而不是預測類別標籤。因此不適用於分類問題。",
      "● 線性迴歸 (Linear Regression)： 是一種監督式學習演演算法，用於預測連續數值輸出，不適用於分類問題。",
      "● 主成分分析 (Principal Component Analysis, PCA)：是一種非監督式的降維技術，用於減少資料集的特徵數量，而不是直接用於分類。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 87,
    "type": "multiple",
    "question": [
      "<pre><code>111. 您訓練了一個模型,用於預測一間網路銀行的客戶流失率,但評估結果顯示這個模型的效能不佳。請問您可以使用下列哪兩種方法提升這個模型的效能?(請選擇2個答案。)</code></pre>"
    ],
    "options": [
      "<code>修改選取的特徵</code>",
      "<code>微調超引數</code>",
      "<code>盡可能縮減初始資料集</code>",
      "<code>使用更快的程式設計語言</code>",
      "<code>選取變化較少的特徵</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>提升模型效能的常用方法包括：",
      "● 修改選取的特徵： 進行更好的特徵工程，例如新增更有資訊量的特徵、移除無關或冗餘特徵、對現有特徵進行轉換。",
      "● 微調超引數： 調整模型的超引數（如學習率、正規化強度、樹的深度等）以找到更優的配置。",
      "",
      "提升模型效能的常用方法不包括：",
      "● 盡可能縮減初始資料集通常會降低效能，除非是為了處理噪聲或過擬合且有特定策略。",
      "● 使用更快的程式設計語言不直接影響模型預測效能（準確度）。",
      "● 選取變化較少的特徵可能造成資訊量不足。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 88,
    "type": "multiple",
    "question": [
      "<pre><code>112. 主管機構和使用者對於透明度的要求越來越高,尤其是針對AI模型。下列哪兩種檔案可協助開發人員為模型提供透明度保證?(請選擇2個答案。)</code></pre>"
    ],
    "options": [
      "<code>包含所有超引數組態和設定的可解釋特徵</code>",
      "<code>建立模型版本的方式和做法</code>",
      "<code>識別至少80%用於訓練模型資料集</code>",
      "<code>針對納入或排除所有外部來源資料所定義的特定篩選方式、做法或標準</code>",
      "<code>資料集偏差的解釋、說明偏差的測試,並確定減少偏差的方法</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 包含所有超引數組態和設定的可解釋特徵：瞭解模型使用了哪些特徵以及模型的配置有助於理解其行為。",
      "● 建立模型版本的方式和做法：清晰的模型版本控制有助於追溯和再現性。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 89,
    "type": "multiple",
    "question": [
      "<pre><code>113. 貴公司建置了AI技術,偵測萵苣是否發生病害。...您必須判斷在哪些情境下這個生產環境 AI可能故障,以便讓團隊事先準備應對策略。請問下列哪兩個情境是可能發生的問題?(請選擇2個答案。)</code></pre>"
    ],
    "options": [
      "<code>田地裡的萵苣看起來可能和訓練照片中的萵苣不同</code>",
      "<code>使用者可能會用這個AI預測其他綠葉蔬菜的病害</code>",
      "<code>研究人員可能會想出更好的神經網路建置方式,提升對訓練照片等影象的分析效能</code>",
      "<code>競爭對手可能會想出偵測同一種病害的方式,並宣稱他們的解決方案比您的更好</code>",
      "<code>種植萵苣的農夫可能不信任AI產生的結果並拒絕使用</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>AI模型故障的常見原因：",
      "● 資料漂移/分佈外資料： 生產環境中的資料（田地裡的萵苣）與訓練資料（照片）存在差異如光照、角度、品種不同，可能導致模型效能下降。",
      "● 錯誤使用/超出範圍：",
      "模型是為偵測萵苣病害設計的，如果使用者嘗試用它來預測其他蔬菜的病害（模型未訓練過的任務），結果很可能不可靠。",
      "",
      "AI模型故障的不常見原因如下：",
      "● 更好的神經網路建置方式及競爭對手宣稱解決方案更好是技術進步和市場競爭，不直接導致現有模型故障。",
      "● 農夫可能不信任AI產生的結果是使用者接受度問題。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 90,
    "type": "multiple",
    "question": [
      "<pre><code>114. 【【114】一間渦輪機製造商設計了AI,用於預測渦輪機是否可能起火。渦輪機從顯示故障跡象到實際起火只有不到100 毫秒的時間,因此AI必須在15毫秒內做出預測...請問下列哪兩種部署方式能使模型的反應最靈敏?”(請選擇2個答案。)</code></pre>"
    ],
    "options": [
      "<code>將模型直接整合至渦輪機的軟體,並且每年升級軟體一次</code>",
      "<code>在渦輪機旁邊的電腦上執行預測程式,並讓渦輪機與電腦保持連線。程式每年更新一次</code>",
      "<code>在網路上執行預測程式,並讓渦輪機透過Wi-Fi 取得預測結果,如此便可確保預測程式一律使用最新模型</code>",
      "<code>收集所有渦輪機的資料,然後每天透過網路進行一次健康情況檢查。健康情況檢查程式每年更新一次</code>",
      "<code>收集所有渦輪機的資料,然後每天在工廠內進行一次健康情況檢查。健康情況檢查程式每年更新一次</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>為了達到極低的延遲（15毫秒內），模型部署應盡可能靠近資料來源和執行端：",
      "● 邊緣部署/嵌入式部署： 將模型直接整合到渦輪機的軟體中，可以最大限度地減少通訊延遲。",
      "● 近邊緣部署： 在渦輪機旁邊的本地電腦上執行預測，透過有線連線，延遲也相對較低。",
      "",
      "以下部署方式不能使模型的反應靈敏：",
      "● 透過網路（尤其是Wi-Fi）會引入不可預測的網路延遲。",
      "● 每天進行渦輪機的資料健康情況檢查是批次檢查，不符合即時預測的需求。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 91,
    "type": "multiple",
    "question": [
      "<pre><code>115. 您是一間保險公司的員工,工作內容是協助資料科學家和工程師將新的模型部署至生產環境;這個模型會用於評估是否要核准客戶的理賠申請。您必須確保貴公司遵循業界與當地的最佳做法。請問您應該注意下列哪兩件事項?(請選擇2個答案。)</code></pre>"
    ],
    "options": [
      "<code>在驗證模型和獲得核准方面是否有任何必須遵守的法律</code>",
      "<code>建置及評估AI的過程是否留下了完整記錄</code>",
      "<code>模型使用的是否為市面上最新的AI技術</code>",
      "<code>工程師是否是在可使用龐大計算能力的雲端建置AI</code>",
      "<code>開發AI模型時是否只使用了公開資料</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>確保合規性和負責任AI部署的關鍵：",
      "● 法律法規遵循： 瞭解並遵守與模型驗證、審批和使用相關的法律法規（如金融監管、資料隱私法）。",
      "● 完整記錄： 保留AI模型開發、訓練、驗證和評估過程的完整記錄，以確保透明度、可追溯性和可審計性。",
      "",
      "以下不是AI部署的關鍵：",
      "● 模型使用的是否為市面上最新的AI技術不一定是首要考量，成熟穩定的技術可能更合適。",
      "● 雲端建置及公開資料是技術和資料來源的選擇，與最佳實踐和合規性的核心關聯較小。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 92,
    "type": "multiple",
    "question": [
      "<pre><code>116. 您一直在追蹤AI系統的指標,而一切運作看起來都如預期般順利。突然之間,您開始收到完全在意料之外的結果,與先前的結果有很大的不同。請問您應該先檢查下列哪兩項看似合理的肇因?(請選擇2個答案。)</code></pre>"
    ],
    "options": [
      "<code>使用者行為改變,或是存取系統的使用者型別改變</code>",
      "<code>使用者裝置上的軟體更新</code>",
      "<code>使用者的裝置空間即將用盡</code>",
      "<code>硬體發生故障</code>",
      "<code>使用者裝置上的感應器髒汙,導致效能降低</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 使用者行為/型別改變： 輸入資料的模式發生變化，可能導致模型輸出異常（資料漂移）。",
      "● 使用者裝置上的軟體更新： 如果AI系統與使用者端軟體有互動，軟體更新可能引入不相容或改變資料傳輸方式，影響系統。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 93,
    "type": "multiple",
    "question": [
      "<pre><code>117. 您接手了與一套機器視覺系統相關的工作。進行偏差分析時,您發現這套系統對膚色較深的人無法有效做出反應。請問在這個情況下,您應該採取哪兩項合乎安全及道德的步驟?(請選擇2個答案。)</code></pre>"
    ],
    "options": [
      "<code>儘快讓系統離線</code>",
      "<code>設法加入新的分類方法訓練資料以提升效能</code>",
      "<code>為了配合系統對較深膚色展現的低效能,調降所有膚色種類的效能</code>",
      "<code>將系統的行銷市場微調成深色膚色人口比例較少的地點</code>",
      "<code>升級用於實作演演算法的軟體版本</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>發現AI系統存在歧視性偏差時應採取：",
      "● 立即行動，控制影響： 如果偏差可能導致嚴重後果或不公平對待，應考慮暫時讓系統離線或限制其使用，直到問題解決。● 解決偏差： 根本的解決方法是改進模型，例如收集更多代表性不足群體的資料（如膚色較深的人的影象）來重新訓練模型，或採用去偏見的演演算法。",
      "",
      "以下行動無關合乎安全及道德：",
      "● 降所有膚色種類的效能是不可取的，會降低整體效能。",
      "● 將系統的行銷市場微調成深色膚色人口比例較少的地點是逃避問題，而非解決。",
      "● 選升級用於實作演演算法的軟體版本不一定能解決資料偏差問題。</code></pre>"
    ],
    "category": "D3_AI演算法與模型訓練"
  },
  {
    "id": 94,
    "type": "multiple",
    "question": [
      "<pre><code>118. 一間網路商店使用AI系統向網路顧客推薦加入訂單中的產品。請問您可以透過下列哪兩種顧客行為評估AI的效能?(請選擇2個答案。)</code></pre>"
    ],
    "options": [
      "<code>顧客是否會點選任何一項推薦產品的連結</code>",
      "<code>顧客是否購買了任何一項推薦產品</code>",
      "<code>AI部署至生產環境後,是否有更多顧客造訪網站</code>",
      "<code>顧客開始使用之後,AI回報的準確率指標是否更好</code>",
      "<code>AI是否順利預測了每位顧客想要的產品</code>",
      "<code>以上皆是</code>"
    ],
    "answer": [
      "A",
      "B"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>評估推薦系統效能的關鍵指標通常與使用者的互動和轉化相關：",
      "● 點選率 (CTR)： 顧客是否點選推薦的產品，反映了推薦的吸引力。",
      "● 轉化率/購買率： 顧客是否最終購買了推薦的產品，直接反映了推薦的商業價值。",
      "",
      "以下關鍵指標不適合於推薦系統效能評估：",
      "● 更多顧客造訪網站網站訪問量可能受多種因素影響，不直接反映推薦系統效能。",
      "● AI回報的內部準確率指標可能與實際使用者行為不完全一致。",
      "● 「順利預測」較為主觀，需要量化指標。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 95,
    "type": "single",
    "question": [
      "<pre><code>119. 一間公司的員工資料如下：進行特徵工程時，我們可以針對「考核」這個欄位，使用三種編碼方式來處理資料，如表格中所示<br>[[image01]]<br>那一個是一位有效編碼 (One-Hot Encoding)</code></pre>"
    ],
    "options": [
      "<code>表格 A</code>",
      "<code>表格 B</code>",
      "<code>表格 C</code>"
    ],
    "answer": [
      "B"
    ],
    "weight": 1,
    "image01": "images/28.png",
    "explanation": [
      "<pre><code>三種編碼方式：",
      "● 標籤編碼 (Label Encoding)： 將每個類別對映到一個唯一的整數。例如：學士=1, 碩士=2, 博士=3。",
      "● One-Hot Encoding (獨熱編碼 / 有效編碼)： 為每個類別建立一個新的二元特徵（欄位）。對於每個樣本，其所屬類別對應的新特徵值為 1，其他所有新特徵值為 0。如果有 k 個類別，就會產生 k 個新的二元特徵。",
      "● 虛擬編碼 (Dummy Encoding)： 與 One-Hot Encoding 類似，但只為 k 個類別建立 k-1 個新的二元特徵。其中一個類別被當作「參考類別」，由所有 k-1 個虛擬變數都為 0 來表示。這樣可以避免多重共線性的問題。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 96,
    "type": "single",
    "question": [
      "<pre><code>120. 這三個模型使用的都是同一個資料集。請問下列哪一個模型是低度擬合?<br>[[imag01]]<br></code></pre>"
    ],
    "options": [
      "<code>模型圖形 1</code>",
      "<code>模型圖形 2</code>",
      "<code>模型圖形 3</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image01": "images/34.png",
    "explanation": [
      "<pre><code>● 模型圖形 1 是一條直線，未能捕捉資料的非線性趨勢，屬於低度擬合（欠擬合）。",
      "● 模型圖形 2 在捕捉資料整體趨勢和避免過度擬合之間取得了較好的平衡，看起來是最佳的模型。",
      "● 模型圖形 3 過於緊密地貼合了訓練資料中的每一個點，包括噪聲，這很可能導致在新的、未見過的資料上表現不佳，屬於過度擬合。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 97,
    "type": "single",
    "question": [
      "<pre><code>121. 這三個模型使用的都是同一個資料集。請問下列哪一個模型是最佳的模型?<br>[[imag01]]<br></code></pre>"
    ],
    "options": [
      "<code>模型圖形 1</code>",
      "<code>模型圖形 2</code>",
      "<code>模型圖形 3</code>"
    ],
    "answer": [
      "B"
    ],
    "weight": 1,
    "image01": "images/34.png",
    "explanation": [
      "<pre><code>● 模型圖形 1 是一條直線，未能捕捉資料的非線性趨勢，屬於低度擬合（欠擬合）。",
      "● 模型圖形 2 在捕捉資料整體趨勢和避免過度擬合之間取得了較好的平衡，看起來是最佳的模型。",
      "● 模型圖形 3 過於緊密地貼合了訓練資料中的每一個點，包括噪聲，這很可能導致在新的、未見過的資料上表現不佳，屬於過度擬合。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 98,
    "type": "single",
    "question": [
      "<pre><code>122. 這三個模型使用的都是同一個資料集。請問下列哪一個模型是過度擬合?<br>[[imag01]]<br></code></pre>"
    ],
    "options": [
      "<code>模型圖形 1</code>",
      "<code>模型圖形 2</code>",
      "<code>模型圖形 3</code>"
    ],
    "answer": [
      "C"
    ],
    "weight": 1,
    "image01": "images/34.png",
    "explanation": [
      "<pre><code>● 模型圖形 1 是一條直線，未能捕捉資料的非線性趨勢，屬於低度擬合（欠擬合）。",
      "什麼是低度擬合 (Underfitting)？",
      "\t低度擬合發生在模型太過簡單，無法捕捉資料中的基本趨勢或規律時。這會導致模型無論是在「訓練資料集」還是「測試資料集」上的表現都很差。",
      "\t訓練階段：準確度低，誤差（Loss）很高。",
      "\t測試階段：同樣準確度低，完全沒有預測能力。",
      "為什麼會發生低度擬合？",
      "\t模型過於簡單： 例如用一條直線（線性模型）去預測彎曲的資料分佈。",
      "\t特徵不足： 提供給模型的資訊太少（例如只用「坪數」就想精準預測「房價」，卻忽略了地段、屋齡等因素）。",
      "\t訓練不足： 訓練次數（Epochs）太少，模型還沒收斂就停止了。",
      "\t過度清理資料： 把一些其實有意義的變動當作雜訊刪除了。",
      "如何解決低度擬合？",
      "\t這在開發過程中通常比過度擬合更好解決，常見對策包括：",
      "\t增加模型複雜度： 增加神經網路的層數、神經元數量，或是改用非線性模型（如從線性回歸改為多項式回歸）。",
      "\t增加特徵工程 (Feature Engineering)： 餵給模型更多有用的資訊（欄位）。",
      "\t延長訓練時間： 增加迭代次數，讓模型有足夠時間找到最佳權重。",
      "\t減少正則化強烈度： 如果正則化 (Regularization) 設定得太嚴苛，模型會因為怕犯錯而不敢學習任何細節，這時應適度放寬。",
      "● 模型圖形 2 在捕捉資料整體趨勢和避免過度擬合之間取得了較好的平衡，看起來是最佳的模型。",
      "● 模型圖形 3 過於緊密地貼合了訓練資料中的每一個點，包括噪聲，這很可能導致在新的、未見過的資料上表現不佳，屬於過度擬合。",
      "為什麼會發生過度擬合？",
      "訓練資料太少： 樣本不足以代表母體，模型容易以偏概全。",
      "模型過於複雜： 例如給一個簡單的線性問題套用極高次方的多項式。",
      "訓練次數過多 (Epochs)： 讓模型在同一堆資料上繞了太多圈，開始鑽牛角尖。",
      "如何解決？（ITS 考試常見對策）",
      "在開發過程中，我們常用以下方法來緩解過度擬合：",
      "增加資料量： 讓模型看更多樣化的範例。",
      "資料增強 (Data Augmentation)： 透過旋轉、縮放等方式增加影像資料的多樣性。",
      "早停法 (Early Stopping)： 當驗證集的錯誤率不再下降時，提早結束訓練。",
      "正則化 (Regularization)： 懲罰過於複雜的權重（例如 L1/L2 正則化）。",
      "隨機森林/Dropout： 在訓練過程中隨機「關掉」一部分神經元或特徵，強迫模型學習更穩健的特徵。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 99,
    "type": "single",
    "question": [
      "<pre><code>123. 貴公司建置了用在網路上推薦產品的AI，而您負責計劃如何建立生產管線並整合至網站。請問您應該將那件事納入考量?</code></pre>"
    ],
    "options": [
      "<code>假如網站顧客人數增加10倍，預測速度是否跟上</code>",
      "<code>預測成效是否良，能顧客買下推薦產品</code>",
      "<code>是否使用了最新AI演演算法來推薦產品</code>",
      "<code>訓練AI演演算法時使用顧客資料是否足夠</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 當您將 AI 模型整合到實際網站並提供即時或近即時的推薦服務時，系統的可擴充套件性與效能（Scalability & Performance） 是最關鍵的因素之一。",
      "● 若網站存取量突然暴增（例如活動期間或成長期），系統必須能夠承受負載並仍提供快速、穩定的推薦結果，否則即使模型很準，也會因延遲導致使用者體驗不佳，進而降低轉換率。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 100,
    "type": "single",
    "question": [
      "<pre><code>124. 【補充】一家銀行希望自動識別信用卡交易中的潛在詐欺行為。這類交易非常罕見。請問這屬於哪種 AI 工作負載？</code></pre>"
    ],
    "options": [
      "<code>異常偵測 (Anomaly Detection)</code>",
      "<code>物件偵測 (Object Detection)</code>",
      "<code>自然語言處理 (NLP)</code>",
      "<code>知識探勘 (Knowledge Mining)</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● **異常偵測** 專門用於識別與正常模式顯著不同的稀有事件或觀察結果，例如信用卡詐欺、裝置故障或網路入侵。<br>● 物件偵測用於影像識別。<br>● NLP 用於文書處理。<br>● 知識探勘用於從非結構化資料中提取資訊。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 101,
    "type": "single",
    "question": [
      "<pre><code>125. 【補充】在電腦視覺中，哪項技術不僅能偵測影像中的物件，還能將影像中的「每個畫素」分類為特定標籤（例如道路、行人、天空）？</code></pre>"
    ],
    "options": [
      "<code>語義分割 (Semantic Segmentation)</code>",
      "<code>影像分類 (Image Classification)</code>",
      "<code>物件偵測 (Object Detection)</code>",
      "<code>光學字元辨識 (OCR)</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● **語義分割** (Semantic Segmentation) 涉及將影像中的每個畫素分配給一個類別，從而精確地描繪出物件的邊界。<br>● 物件偵測只會給出物件的邊界框 (Bounding Box)。<br>● 影像分類是對整張圖片給出一個標籤。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 102,
    "type": "single",
    "question": [
      "<pre><code>126. 【補充】您正在開發一個聊天機器人，需要從使用者的輸入句子「我想預訂明天去臺北的機票」中，提取出「明天」和「臺北」這類關鍵資訊。這屬於 NLP 中的哪項功能？</code></pre>"
    ],
    "options": [
      "<code>命名實體辨識 (NER)</code>",
      "<code>情感分析 (Sentiment Analysis)</code>",
      "<code>語言偵測 (Language Detection)</code>",
      "<code>關鍵短語擷取 (Key Phrase Extraction)</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● **命名實體辨識 (NER)** 旨在識別文字中的特定實體，如日期（明天）、地點（臺北）、人名、組織等。<br>● 情感分析判斷情緒正負向。<br>● 關鍵短語擷取是提取重點主題而非特定實體類別。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 103,
    "type": "single",
    "question": [
      "<pre><code>127. 【補充】在訓練 AI 模型時，為了保護個人隱私，您在資料集中加入雜訊，使得無法從輸出反推回特定個人的資料。這符合「負責任 AI」的哪項原則？</code></pre>"
    ],
    "options": [
      "<code>隱私權與安全性 (Privacy & Security)</code>",
      "<code>公平性 (Fairness)</code>",
      "<code>包容性 (Inclusiveness)</code>",
      "<code>透明度 (Transparency)</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● **隱私權與安全性** 原則要求保護使用者資料。題目描述的技術稱為「差異化隱私 (Differential Privacy)」，是保護隱私的常見技術手段。<br>● 公平性是關於不歧視。<br>● 透明度是關於模型的可解釋性。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 104,
    "type": "single",
    "question": [
      "<pre><code>128. 【補充】在準備機器學習的資料時，若特徵 A 的範圍是 0-1，而特徵 B 的範圍是 0-10000，這可能會導致某些演演算法（如 KNN 或 梯度下降）效能不佳。您應該執行什麼步驟來解決此問題？</code></pre>"
    ],
    "options": [
      "<code>特徵縮放 (Feature Scaling) 或 標準化</code>",
      "<code>特徵選擇 (Feature Selection)</code>",
      "<code>資料擴增 (Data Augmentation)</code>",
      "<code>移除特徵 B</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 當特徵之間的數值範圍差異過大時，會影響基於距離的演演算法（如 KNN）或最佳化過程。**特徵縮放**（如歸一化或標準化）可以將所有特徵調整到相似的範圍，確保模型公平地對待每個特徵。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 105,
    "type": "single",
    "question": [
      "<pre><code>129. 【補充】您正在評估一個預測罕見疾病的模型。該資料集中只有 1% 的樣本是陽性（有病）。在此情況下，僅看「準確率 (Accuracy)」可能會產生誤導。您應該優先參考哪項指標來平衡考量精確率 (Precision) 和召回率 (Recall)？</code></pre>"
    ],
    "options": [
      "<code>F1 分數 (F1-Score)</code>",
      "<code>平均絕對誤差 (MAE)</code>",
      "<code>R 平方 (R-Squared)</code>",
      "<code>準確率 (Accuracy)</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 在資料極度不平衡的情況下，**F1 分數** 是更好的指標，因為它是精確率和召回率的調和平均數，能更真實地反映模型對少數類別的預測能力。<br>● MAE 和 R 平方是用於迴歸問題的指標。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 106,
    "type": "single",
    "question": [
      "<pre><code>130. 【補充】關於自動化機器學習 (AutoML)，下列敘述何者正確？</code></pre>"
    ],
    "options": [
      "<code>它可以自動嘗試多種演演算法和超引數組合，以找出最佳模型</code>",
      "<code>它完全不需要任何訓練資料</code>",
      "<code>它只能用於非監督式學習</code>",
      "<code>它無法部署模型，只能用於訓練</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● **AutoML** 的主要優勢在於自動化特徵工程、模型選擇和超引數調整的過程，幫助開發者快速找到表現最好的模型。<br>● 它仍然需要訓練資料，且廣泛用於監督式學習（分類、迴歸）。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 107,
    "type": "single",
    "question": [
      "<pre><code>131. 【補充】您希望將訓練好的 AI 模型部署到雲端、邊緣裝置等多種環境中，且保證執行環境的一致性。下列哪項技術最適合？</code></pre>"
    ],
    "options": [
      "<code>容器化 (Containerization，如 Docker)</code>",
      "<code>虛擬機器 (Virtual Machine)</code>",
      "<code>直接安裝在實體伺服器</code>",
      "<code>使用 ZIP 壓縮檔複製程式碼</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● **容器化 (如 Docker)** 將模型及其所有依賴項打包在一起，確保在任何支援容器的環境中都能以相同的方式執行，是現代 AI 模型部署的標準做法。</code></pre>"
    ],
    "category": "D4_應用整合、部署與監控"
  },
  {
    "id": 108,
    "type": "single",
    "question": [
      "<pre><code>132. 【補充】知識探勘 (Knowledge Mining) 解決方案中，「索引 (Indexer)」的主要作用是什麼？</code></pre>"
    ],
    "options": [
      "<code>掃描來源內容，使其可被搜尋並建立索引</code>",
      "<code>將圖片轉換為文字</code>",
      "<code>翻譯多種語言的檔案</code>",
      "<code>自動生成檔案的摘要</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 在 Azure Cognitive Search 等知識探勘服務中，**索引器 (Indexer)** 負責連線資料來源、讀取資料、序列化資料並將其傳遞給搜尋引擎以建立索引，使內容可被查詢。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 109,
    "type": "single",
    "question": [
      "<pre><code>133. 【補充】關於卷積神經網路 (CNN)，下列敘述何者最準確？</code></pre>"
    ],
    "options": [
      "<code>它特別擅長處理影像資料，利用卷積層提取特徵</code>",
      "<code>它主要用於處理時間序列資料</code>",
      "<code>它是一種非監督式學習演演算法</code>",
      "<code>它不具備任何隱藏層 (Hidden Layer)</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● **卷積神經網路 (CNN)** 是深度學習的一種，特別設計用於處理網格狀資料（如影像）。它利用卷積層 (Convolutional Layers) 自動提取影像中的空間層次特徵（如邊緣、紋理、形狀）。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 110,
    "type": "single",
    "question": [
      "<pre><code>134. 【補充】在設計聊天機器人 (Chatbot) 時，使用者的輸入句子為「幫我預訂一張去倫敦的機票」。\n其中「預訂機票」代表使用者的什麼？「倫敦」又代表什麼？</code></pre>"
    ],
    "options": [
      "<code>「預訂機票」是意圖 (Intent)，「倫敦」是實體 (Entity)</code>",
      "<code>「預訂機票」是實體 (Entity)，「倫敦」是意圖 (Intent)</code>",
      "<code>兩者都是意圖</code>",
      "<code>兩者都是實體</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● **意圖 (Intent)**：使用者想要達成的目標或動作（如：訂票、查詢天氣）。<br>● **實體 (Entity)**：意圖中具體的細節或引數，用來補充說明意圖（如：地點、時間、數量）。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 111,
    "type": "single",
    "question": [
      "<pre><code>135. 【補充】某款 AI 應用程式可以分析照片中的人臉，並估測出該人物的「年齡」和「情緒」，但「不知道」這個人是誰。\n這屬於電腦視覺中的哪項功能？</code></pre>"
    ],
    "options": [
      "<code>臉部特徵分析 (Facial Analysis)</code>",
      "<code>臉部識別 (Face Identification)</code>",
      "<code>臉部驗證 (Face Verification)</code>",
      "<code>光學字元辨識 (OCR)</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● **臉部特徵分析**：分析臉部屬性（如年齡、性別、情緒、是否戴眼鏡），但不涉及確認身分。<br>● **臉部識別**：將臉部與資料庫比對，回答「這是誰？」。<br>● **臉部驗證**：比對兩張臉是否為同一人（1對1比對，如手機解鎖）。</code></pre>"
    ],
    "category": "D2_資料收集、處理與工程"
  },
  {
    "id": 112,
    "type": "single",
    "question": [
      "<pre><code>136. 【補充】自動駕駛汽車的 AI 系統必須經過嚴格測試，確保在惡劣天氣或突發狀況下也能安全運作，不會對人類造成傷害。\n這最主要符合微軟「負責任 AI」的哪項原則？</code></pre>"
    ],
    "options": [
      "<code>可靠性與安全性 (Reliability & Safety)</code>",
      "<code>隱私權與安全性 (Privacy & Security)</code>",
      "<code>包容性 (Inclusiveness)</code>",
      "<code>公平性 (Fairness)</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● **可靠性與安全性**：強調 AI 系統在預期和非預期的情況下（如極端條件）都能穩定、安全地執行，且不會對人身安全造成威脅。<br>● 隱私權與安全性：側重於資料保護。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  },
  {
    "id": 113,
    "type": "single",
    "question": [
      "<pre><code>137. 【補充】關於「迴歸模型 (Regression)」的評估指標，下列敘述何者正確？</code></pre>"
    ],
    "options": [
      "<code>R 平方 (R²) 值越接近 1，表示模型擬合度越好</code>",
      "<code>平均絕對誤差 (MAE) 值越大，表示模型越準確</code>",
      "<code>均方根誤差 (RMSE) 值越大，表示模型越準確</code>",
      "<code>迴歸模型通常使用混淆矩陣 (Confusion Matrix) 來評估</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● **R 平方 (Coefficient of Determination)**：衡量模型解釋變異的比例，範圍 0-1，越接近 1 表示模型解釋力越強。<br>● MAE 和 RMSE 都是衡量「誤差」，所以數值越「小」越好。<br>● 混淆矩陣是用於「分類」問題。</code></pre>"
    ],
    "category": "D3_AI演算法與模型訓練"
  },
  {
    "id": 114,
    "type": "single",
    "question": [
      "<pre><code>138. 【補充】您正在使用「翻譯服務 (Translator)」開發一個應用程式，該程式需要將使用者的「語音」即時翻譯成另一種語言的「語音」。\n請問正確的處理流程通常為何？</code></pre>"
    ],
    "options": [
      "<code>語音轉文字 -> 翻譯文字 -> 文字轉語音</code>",
      "<code>直接進行語音對語音的波形轉換</code>",
      "<code>語音轉影像 -> 影像翻譯 -> 影像轉語音</code>",
      "<code>文字轉語音 -> 翻譯語音 -> 語音轉文字</code>"
    ],
    "answer": [
      "A"
    ],
    "weight": 1,
    "image": null,
    "explanation": [
      "<pre><code>● 目前主流的語音翻譯技術流程為：\n1. **Speech-to-Text (STT)**: 先將來源語音識別為文字。\n2. **Translation**: 將文字翻譯成目標語言文字。\n3. **Text-to-Speech (TTS)**: 將翻譯後的文字合成目標語言語音。</code></pre>"
    ],
    "category": "D1_AI問題定義與倫理"
  }
];
    function parseAnswerToIndex(val) {
        if (typeof val === 'number') return val - 1;
        if (typeof val === 'string') {
            const v = val.toUpperCase();
            if (v === 'Y') return 0; if (v === 'N') return 1;
            const code = v.charCodeAt(0);
            if (code >= 65 && code <= 90) return code - 65;
            return parseInt(val) - 1;
        }
        return -1;
    }
    let currentIndex = 0;
    let correctSet = new Set(), incorrectSet = new Set(), correctedSet = new Set(), userAnswers = {}; 
    const SUBJECT_ID = 'itsai';
    const CORR_KEY = SUBJECT_ID + '_correct_v1', INCORR_KEY = SUBJECT_ID + '_incorrect_v1', CORR_EDIT_KEY = SUBJECT_ID + '_corrected_v1', INDEX_KEY = SUBJECT_ID + '_index_v1', ANSWERS_KEY = SUBJECT_ID + '_answers_v1';
    function loadState() {
        try {
            const sCorr = localStorage.getItem(CORR_KEY), sIncorr = localStorage.getItem(INCORR_KEY), sEdit = localStorage.getItem(CORR_EDIT_KEY), sIdx = localStorage.getItem(INDEX_KEY), sAns = localStorage.getItem(ANSWERS_KEY);
            if (sCorr) correctSet = new Set(JSON.parse(sCorr));
            if (sIncorr) incorrectSet = new Set(JSON.parse(sIncorr));
            if (sEdit) correctedSet = new Set(JSON.parse(sEdit));
            if (sIdx) currentIndex = parseInt(sIdx) || 0;
            if (sAns) userAnswers = JSON.parse(sAns);
        } catch(e) {}
    }
    function saveState() {
        try {
            localStorage.setItem(CORR_KEY, JSON.stringify([...correctSet]));
            localStorage.setItem(INCORR_KEY, JSON.stringify([...incorrectSet]));
            localStorage.setItem(CORR_EDIT_KEY, JSON.stringify([...correctedSet]));
            localStorage.setItem(INDEX_KEY, currentIndex.toString());
            localStorage.setItem(ANSWERS_KEY, JSON.stringify(userAnswers));
        } catch(e) {}
    }
    function resetProgress() { 
        if(confirm('確定清除紀錄嗎？')) { 
            try { localStorage.removeItem(CORR_KEY); localStorage.removeItem(INCORR_KEY); localStorage.removeItem(CORR_EDIT_KEY); localStorage.removeItem(INDEX_KEY); localStorage.removeItem(ANSWERS_KEY); } catch(e) {}
            location.reload(); 
        } 
    }
    function toggleSidebar() { document.getElementById('sidebar').classList.toggle('active'); }
    function processContent(content, item) {
        if (!content) return '';
        const lines = Array.isArray(content) ? content : [String(content)];
        return lines.join('\n').replace(/\[\[image(\d+)\]\]/g, (match, p1) => {
            const num = parseInt(p1, 10);
            const src = item['image' + num] || item['image' + p1] || item['image'];
            return src ? `<img src="${src}" class="q-img">` : match;
        });
    }
    function toggleExplanation(forceShow = null) {
        const el = document.getElementById('ans-section'), btn = document.getElementById('toggle-exp-btn');
        if (!el || !btn) return;
        const isShow = (forceShow !== null) ? forceShow : (el.style.display !== 'block');
        el.style.display = isShow ? 'block' : 'none';
        if (isShow) setTimeout(() => { if(window.Prism) Prism.highlightAll(); }, 50);
    }
    function checkAnswer(element, qIdx, optIdx, event) {
        const item = quizData[qIdx], isMultiple = item.type === 'multiple';
        let answers = item.answer; if (!Array.isArray(answers)) answers = [answers];
        const correctIndices = answers.map(a => parseAnswerToIndex(a));
        const input = element.querySelector('input');
        if (event && event.target !== input) { if (isMultiple) input.checked = !input.checked; else input.checked = true; }
        if (isMultiple) {
            const inputs = document.querySelectorAll(`input[name="q${qIdx}"]`);
            let selected = []; inputs.forEach((inp, idx) => { if (inp.checked) selected.push(idx); });
            userAnswers[qIdx] = selected;
            element.classList.toggle('correct', input.checked && correctIndices.includes(optIdx));
            element.classList.toggle('incorrect', input.checked && !correctIndices.includes(optIdx));
            const isPerfect = selected.length === correctIndices.length && selected.every(v => correctIndices.includes(v));
            if (isPerfect) {
                if (incorrectSet.has(qIdx)) { incorrectSet.delete(qIdx); correctedSet.add(qIdx); }
                else if (!correctedSet.has(qIdx)) { correctSet.add(qIdx); }
                inputs.forEach(i => i.disabled = true); toggleExplanation(true);
            } else if (selected.some(v => !correctIndices.includes(v)) || selected.length > correctIndices.length) {
                incorrectSet.add(qIdx); correctSet.delete(qIdx); correctedSet.delete(qIdx);
            }
        } else {
            if (correctSet.has(qIdx) || correctedSet.has(qIdx)) return;
            userAnswers[qIdx] = optIdx;
            if (correctIndices.includes(optIdx)) {
                element.classList.add('correct');
                if (incorrectSet.has(qIdx)) { incorrectSet.delete(qIdx); correctedSet.add(qIdx); }
                else { correctSet.add(qIdx); }
                document.querySelectorAll(`input[name="q${qIdx}"]`).forEach(i => i.disabled = true);
            } else {
                element.classList.add('incorrect'); incorrectSet.add(qIdx);
                const ci = document.getElementById(`o${correctIndices[0]}`); if (ci) ci.closest('.option-item').classList.add('correct');
            }
            toggleExplanation(true);
        }
        saveState(); updateUI();
    }
    function checkSubAnswer(element, qIdx, optIdx, subIdx, event) {
        const item = quizData[qIdx];
        let answers = item.answer; if (!Array.isArray(answers)) answers = [answers];
        const correctSubIdx = parseAnswerToIndex(answers[optIdx]), input = element.querySelector('input');
        if (event && event.target !== input) input.checked = true;
        if (!userAnswers[qIdx]) userAnswers[qIdx] = {}; userAnswers[qIdx][optIdx] = subIdx;
        element.parentElement.querySelectorAll('.sub-opt-container').forEach(el => el.classList.remove('selected'));
        element.classList.add('selected');
        if (subIdx === correctSubIdx) {
            element.classList.add('correct');
            const totalSub = (item.quiz || item.options || []).length;
            const curCorrect = document.querySelectorAll('.sub-opt-container.correct').length;
            if (curCorrect === totalSub) {
                if (incorrectSet.has(qIdx)) { incorrectSet.delete(qIdx); correctedSet.add(qIdx); }
                else if (!correctedSet.has(qIdx)) { correctSet.add(qIdx); }
                toggleExplanation(true);
            }
            document.querySelectorAll(`input[name="q${qIdx}_opt${optIdx}"]`).forEach(i => i.disabled = true);
        } else {
            element.classList.add('incorrect'); incorrectSet.add(qIdx);
            const ci = document.getElementById(`o${optIdx}_s${correctSubIdx}`); if (ci) ci.parentElement.classList.add('correct');
            toggleExplanation(true);
        }
        saveState(); updateUI();
    }
    function evaluateCurrentQuestion() {
        const item = quizData[currentIndex], qIdx = currentIndex;
        if (correctSet.has(qIdx) || correctedSet.has(qIdx) || incorrectSet.has(qIdx)) return;
        const saved = userAnswers[qIdx]; if (!saved) return; 
        let answers = item.answer; if (!Array.isArray(answers)) answers = [answers];
        const correctIndices = answers.map(a => parseAnswerToIndex(a));
        if (item.type === 'multiple') {
            const selected = Array.isArray(saved) ? saved : []; if (selected.length === 0) return;
            if (selected.length === correctIndices.length && selected.every(v => correctIndices.includes(v))) correctSet.add(qIdx); else incorrectSet.add(qIdx);
        } else if (String(item.quiz || item.options || "").includes('|')) {
            const totalSub = (item.quiz || item.options || []).length;
            let allCorrect = (Object.keys(saved).length === totalSub);
            if (allCorrect) { for(let i=0; i<totalSub; i++) if (parseInt(saved[i]) != parseAnswerToIndex(answers[i])) { allCorrect = false; break; } }
            if (allCorrect) correctSet.add(qIdx); else incorrectSet.add(qIdx);
        }
        saveState(); updateUI();
    }
    function nextQuestion() { evaluateCurrentQuestion(); if (currentIndex < quizData.length-1) renderQuestion(currentIndex+1); }
    function prevQuestion() { evaluateCurrentQuestion(); if (currentIndex > 0) renderQuestion(currentIndex-1); }
    function jumpTo(idx) { evaluateCurrentQuestion(); renderQuestion(idx); }
    function prepareAndPrint(onlyMistakes = false) {
        const area = document.getElementById('review-area');
        let title = "ITS AI 認證完整解析";
        let targetItems = quizData.map((item, idx) => ({ item, idx }));
        if (onlyMistakes) {
            targetItems = targetItems.filter(({ idx }) => incorrectSet.has(idx) || correctedSet.has(idx));
            if (targetItems.length === 0) { alert('目前沒有錯題或訂正紀錄可供列印！'); return; }
            title = "ITS AI 訂正解析講義";
        }
        area.innerHTML = `<h1 class="text-center mb-4" style="color:#212529">${title}</h1>`;
        targetItems.forEach(({ item, idx }) => {
            const div = document.createElement('div'); div.className = 'review-item';
            const optsRaw = item.quiz || item.options || [];
            const opts = Array.isArray(optsRaw) ? optsRaw : [optsRaw];
            const isNum = (item.labelType === 'num');
            const numStyle = (item.labelType === 'none' || item.hideLabel) ? 'style="display:none"' : '';
            
            let optHtml = opts.map((o, i) => {
                if (String(o).includes('|')) {
                    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                    const customLabelField = "question" + alphabet[i];
                    let customLabel = "";
                    if (item[customLabelField]) {
                        customLabel = Array.isArray(item[customLabelField]) ? item[customLabelField].join(' ') : item[customLabelField];
                    }
                    const displayLabel = customLabel || `選項 ${i + 1}`;

                    const subLabels = o.split('|').map((s, si) => {
                        const lbl = isNum ? (si + 1) : String.fromCharCode(65 + si);
                        return `<span class="opt-num" ${numStyle}>(${lbl})</span>${s}`;
                    }).join(' ');
                    return `<div class="review-opt-line"><span class="fw-bold">${displayLabel}</span> ${subLabels}</div>`;
                } else {
                    const lbl = isNum ? (i + 1) + "." : `(${String.fromCharCode(65 + i)})`;
                    return `<div class="review-opt-line"><span class="opt-num" ${numStyle}>${lbl} </span>${o}</div>`;
                }
            }).join('');
            
            // 處理題目清理：若是陣列，僅清理第一項 (優化：支援 HTML 標籤開頭)
            let cleanQ = item.question;
            const numRegex = /^((?:<[^>]+>)*)\d+\.\s*/;
            if (Array.isArray(cleanQ)) {
                cleanQ = [...cleanQ];
                if (cleanQ.length > 0) cleanQ[0] = cleanQ[0].replace(numRegex, '$1');
            } else {
                cleanQ = String(cleanQ).replace(numRegex, '$1');
            }
            
            let imgHtml = item.image ? `<div class="text-center my-2"><img src="${item.image}" class="q-img"></div>` : '';
            const answers = Array.isArray(item.answer) ? item.answer : [item.answer];
            const ansText = answers.map(a => {
                if (String(a).toUpperCase() === 'Y' || String(a).toUpperCase() === 'N') return a;
                const idx = parseAnswerToIndex(a);
                if (idx < 0) return a;
                return isNum ? (idx + 1) : String.fromCharCode(65 + idx);
            }).join(', ');

            div.innerHTML = `<div class="review-q-text"><b>${idx+1}.</b> <div class="q-content">${processContent(cleanQ, item)}</div></div>${imgHtml}<div class="review-opts" style="margin-left:0">${optHtml}</div><div class="review-ans">正確答案：${ansText}</div><div class="review-exp">${processContent(item.explanation || '暫無解析。', item)}</div>`;
            area.appendChild(div);
        });
        if(window.Prism) Prism.highlightAll();
        setTimeout(() => { window.print(); }, 100);
    }
    function renderQuestion(index) {
        window.scrollTo(0, 0); currentIndex = index; const item = quizData[index];
        const container = document.getElementById('question-area') || document.getElementById('question-container');
        const opts = item.quiz || item.options || [];
        const pBtn = document.getElementById('side-btn-prev'); if (pBtn) pBtn.style.display = (index === 0) ? 'none' : 'flex';
        let typeLabel = opts.some(o => String(o).includes('|')) ? "題組" : (item.type === 'multiple' ? "複選" : "單選");
        container.innerHTML = `
            <div class="card question-card">
                <div class="question-header"><div><span class="badge bg-primary me-2">題目 ${index + 1} / ${quizData.length}</span><span class="badge bg-info type-badge">${typeLabel}</span></div><div class="category-tag">${item.category || '一般'}</div></div>
                <div class="question-body"><div>${processContent(item.question, item)}</div>${item.image ? `<img src="${item.image}" class="q-img">` : ''}<div class="options-area"></div><div class="text-center mt-4 pt-3 border-top"><button class="btn btn-outline-primary px-4" id="toggle-exp-btn" onclick="toggleExplanation()">👁️ 顯示答案 / 解析</button></div><div class="answer-section" id="ans-section"><h6 class="fw-bold mb-3">正確答案: <span class="text-blue">${Array.isArray(item.answer) ? item.answer.join(', ') : item.answer}</span></h6><div class="explanation">${processContent(item.explanation || '暫無解析。', item)}</div></div></div>
            </div>`;
        const optionsArea = container.querySelector('.options-area');
        opts.forEach((opt, oIdx) => {
            let labelText = `(${String.fromCharCode(65 + oIdx)}) `;
            if (item.labelType === 'num') labelText = `${oIdx + 1}. `;
            const numStyle = (item.labelType === 'none' || item.hideLabel) ? 'style="display:none"' : '';

            if (String(opt).includes('|')) {
                const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                const customLabelField = "question" + alphabet[oIdx];
                let customLabel = "";
                if (item[customLabelField]) {
                    customLabel = Array.isArray(item[customLabelField]) ? item[customLabelField].join('<br>') : item[customLabelField];
                }
                const displayLabel = customLabel || `選項 ${oIdx + 1}`;

                let sHtml = `<div class="mt-2 mb-1"><code>${displayLabel}</code></div><div class="d-flex flex-wrap gap-2">`;
                opt.split('|').forEach((s, subIdx) => { 
                    let subLabel = `(${String.fromCharCode(65 + subIdx)}) `;
                    if (item.labelType === 'num') subLabel = `(${subIdx+1}) `;
                    sHtml += `<div class="sub-opt-container p-2 border rounded bg-light" onclick="checkSubAnswer(this, ${index}, ${oIdx}, ${subIdx}, event)" style="cursor:pointer; font-size:0.9rem"><input class="form-check-input" type="radio" name="q${index}_opt${oIdx}" id="o${oIdx}_s${subIdx}"><span class="opt-num" ${numStyle}>${subLabel}</span> ${s}</div>`; 
                });
                optionsArea.innerHTML += sHtml + '</div></div>';
            } else { optionsArea.innerHTML += `<div class="option-item" onclick="checkAnswer(this, ${index}, ${oIdx}, event)"><input class="form-check-input" type="${item.type==='multiple'?'checkbox':'radio'}" name="q${index}" id="o${oIdx}"><span class="opt-num" ${numStyle}>${labelText}</span>${opt}</div>`; }
        });
        const saved = userAnswers[index], completed = correctSet.has(index) || incorrectSet.has(index) || correctedSet.has(index);
        let answers = item.answer; if (!Array.isArray(answers)) answers = [answers];
        let cIdxs = answers.map(a => parseAnswerToIndex(a));
        if (opts.some(o => String(o).includes('|'))) {
            opts.forEach((opt, r) => {
                const correctSubIdx = parseAnswerToIndex(answers[r]); const savedSubIdx = (saved && typeof saved === 'object') ? saved[r] : undefined;
                opt.split('|').forEach((_, subIdx) => {
                    const inp = document.getElementById(`o${r}_s${subIdx}`); if (!inp) return;
                    if (savedSubIdx !== undefined && parseInt(savedSubIdx) === subIdx) { inp.checked = true; inp.parentElement.classList.add('selected'); }
                    if (completed) { if (subIdx === correctSubIdx) inp.parentElement.classList.add('correct'); else if (savedSubIdx !== undefined && parseInt(savedSubIdx) === subIdx) inp.parentElement.classList.add('incorrect'); }
                });
            });
        } else if (saved !== undefined) {
            if (Array.isArray(saved)) {
                saved.forEach(idx => { const inp = document.getElementById(`o${idx}`); if (inp) { inp.checked = true; if(completed) inp.closest('.option-item').classList.add(cIdxs.includes(idx) ? 'correct' : 'incorrect'); } });
                if(completed) cIdxs.forEach(ci => { const inp = document.getElementById(`o${ci}`); if (inp) inp.closest('.option-item').classList.add('correct'); });
            } else {
                const inp = document.getElementById(`o${saved}`); if (inp) { inp.checked = true; if(completed) inp.closest('.option-item').classList.add(cIdxs.includes(saved) ? 'correct' : 'incorrect'); }
                if(completed && !cIdxs.includes(saved)) { const ci = document.getElementById(`o${cIdxs[0]}`); if(ci) ci.closest('.option-item').classList.add('correct'); }
            }
        }
        if (completed) { toggleExplanation(true); document.querySelectorAll(`input[name^="q${index}"]`).forEach(i => i.disabled = true); }
        updateUI(); 
        setTimeout(() => { if(window.Prism) Prism.highlightAll(); }, 50);
        saveState();
    }
    function updateUI() {
        const stats = document.getElementById('progress-stats'); if (stats) stats.innerHTML = `✅${correctSet.size} ❌${incorrectSet.size} 🟠${correctedSet.size} <span class="ms-1 small" style="opacity:0.7">/ ${quizData.length}</span>`;
        const grid = document.getElementById('progress-grid'); grid.innerHTML = '';
        quizData.forEach((_, i) => {
            const n = document.createElement('div'); n.className = 'q-node'; if (i === currentIndex) { n.classList.add('active'); setTimeout(() => n.scrollIntoView({ block: 'center', behavior: 'smooth' }), 100); }
            if (incorrectSet.has(i)) n.classList.add('incorrect'); else if (correctedSet.has(i)) n.classList.add('corrected'); else if (correctSet.has(i)) n.classList.add('correct');
            n.innerText = i + 1; n.onclick = () => jumpTo(i); grid.appendChild(n);
        });
    }
    loadState(); renderQuestion(currentIndex);
</script>
</body>
</html>