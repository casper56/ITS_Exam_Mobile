<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>ITS Database 模擬測驗</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Prism.js for Syntax Highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        body {
            background-color: #f8f9fa;
            font-family: "Microsoft JhengHei", "Segoe UI", Roboto, sans-serif;
            overflow-y: scroll; 
        }
        
        /* Layout */
        .main-wrapper {
            display: flex;
            min-height: 100vh;
        }
        
        /* Sidebar */
        .sidebar {
            width: 280px;
            background: #fff;
            border-right: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            z-index: 1000;
            transition: transform 0.3s ease;
        }
        
        .sidebar-header {
            padding: 15px;
            border-bottom: 1px solid #dee2e6;
            background: #212529;
            color: #fff;
        }
        
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        .sidebar-footer {
            padding: 15px;
            border-top: 1px solid #dee2e6;
            background: #f8f9fa;
        }

        /* Main Content */
        .content-area {
            flex: 1;
            margin-left: 280px; /* Match sidebar width */
            padding: 30px;
            transition: margin-left 0.3s ease;
        }

        /* Mobile Responsive */
        @media (max-width: 992px) {
            .sidebar {
                transform: translateX(-100%);
            }
            .sidebar.active {
                transform: translateX(0);
            }
            .content-area {
                margin-left: 0;
            }
            .mobile-toggle {
                display: block !important;
            }
        }

        /* Question Card */
        .question-card {
            min-height: 500px;
            border: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
            background: #fff;
            border-radius: 8px;
            overflow: hidden;
        }
        .question-header {
            background-color: #fff;
            border-bottom: 2px solid #0d6efd;
            padding: 20px;
            font-weight: bold;
            color: #0d6efd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .question-body {
            padding: 40px;
            font-size: 1.1rem;
        }
        .question-image {
            max-width: 100%;
            height: auto;
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* Options */
        .option-item {
            list-style: none;
            margin-bottom: 12px;
            padding: 15px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .option-item:hover {
            background-color: #f8f9fa;
            border-color: #adb5bd;
        }
        .option-item.correct {
            background-color: #d1e7dd !important;
            border-color: #badbcc !important;
            color: #0f5132 !important;
        }
        .option-item.incorrect {
            background-color: #f8d7da !important;
            border-color: #f5c2c7 !important;
            color: #842029 !important;
        }
        .sub-opt-container.correct {
            background-color: #d1e7dd !important;
            border-color: #badbcc !important;
        }
        .sub-opt-container.incorrect {
            background-color: #f8d7da !important;
            border-color: #f5c2c7 !important;
        }
        .sub-question-label {
            font-weight: bold;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #495057;
            border-left: 4px solid #198754;
            padding-left: 10px;
            font-size: 1.05rem;
        }

        /* Answer Section */
        .answer-section {
            display: none;
            margin-top: 30px;
            padding: 25px;
            background-color: #f0f7ff;
            border-left: 5px solid #0d6efd;
            border-radius: 4px;
        }

        /* Grid Nodes */
        .progress-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 6px;
        }
        .q-node {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background-color: #fff;
            cursor: pointer;
            font-size: 0.85rem;
            color: #6c757d;
        }
        .q-node:hover {
            background-color: #e9ecef;
        }
        
        .q-node.wrong {
            background-color: #f8d7da;
            border-color: #f5c2c7;
            color: #842029;
        }
        .q-node.visited {
            background-color: #d1e7dd;
            border-color: #badbcc;
            color: #0f5132;
        }
        

        /* Navigation Buttons */
        .nav-btn-group {
            display: flex;
            gap: 15px;
            margin-top: 30px;
            justify-content: center;
        }
        .nav-btn {
            min-width: 120px;
        }

        .mobile-toggle {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1100;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #212529;
            color: white;
            border: none;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        code {
            font-family: Consolas, Monaco, monospace;
            color: #d63384;
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 4px;
        }

        /* Zoom Controls */
        .zoom-controls {
            position: fixed;
            bottom: 90px;
            right: 20px;
            z-index: 1100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .zoom-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: #fff;
            color: #0d6efd;
            border: 1px solid #0d6efd;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            padding: 0;
            line-height: 1;
        }
        .zoom-btn:active {
            background: #0d6efd;
            color: #fff;
            transform: scale(0.95);
        }
    </style>
</head>
<body>

<div class="main-wrapper">
    <!-- Sidebar -->
    <nav class="sidebar" id="sidebar">
        <div class="sidebar-header d-flex justify-content-between align-items-center">
            <h5 class="m-0">題目列表</h5>
            <small class="text-white-50" id="progress-stats"></small>
        </div>
        
        <div class="sidebar-content">
            <div class="d-flex justify-content-between small mb-2 text-muted">
                <span><span style="display:inline-block;width:10px;height:10px;background:#fff;border:1px solid #ccc"></span> 未讀</span>
                <span><span style="display:inline-block;width:10px;height:10px;background:#d1e7dd;border:1px solid #badbcc"></span> 答對</span>
                <span><span style="display:inline-block;width:10px;height:10px;background:#f8d7da;border:1px solid #f5c2c7"></span> 答錯</span>
            </div>
            <div class="progress-grid" id="progress-grid">
                <!-- Grid items generated by JS -->
            </div>
        </div>

        <div class="sidebar-footer">
            <a href="../index.html" class="btn btn-outline-secondary btn-sm w-100 mb-2">🏠 回首頁</a>
            <button class="btn btn-outline-danger btn-sm w-100" onclick="resetProgress()">
                🗑️ 重置進度
            </button>
        </div>
    </nav>

    <!-- Mobile Toggle -->
    <button class="mobile-toggle" onclick="toggleSidebar()">
        ☰
    </button>

    <!-- Main Content -->
    <main class="content-area" id="main-content">
        <div class="container-fluid" style="max-width: 1000px;">
            <h2 class="text-center mb-4">ITS Database 模擬測驗</h2>
            <div id="question-container">
                <!-- Question injected here -->
            </div>

            <div class="nav-btn-group">
                <button class="btn btn-secondary nav-btn" id="btn-prev" onclick="prevQuestion()">⬅️ 上一題</button>
                <button class="btn btn-primary nav-btn" id="btn-next" onclick="nextQuestion()">下一題 ➡️</button>
            </div>
        </div>
    </main>
</div>

    <!-- Zoom Controls V6 -->
    <div class="zoom-controls">
        <button class="zoom-btn" type="button" onclick="doZoom(2)">+</button>
        <button class="zoom-btn" type="button" onclick="doZoom(-2)">-</button>
    </div>

<!-- Scripts -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

<script>
    const quizData = [{"id": 1, "question": "1. 您有兩個資料表,分別名為 SalesPerson 與 Sales。\n您需要確保 Sales 資料表中的每筆記錄都在 SalesPerson 資料表中保存有效的相關\n聯銷售人員記錄。\n請問您應該將哪一個資料庫物件新增至 Sales 資料表?", "options": ["叢集索引", "外部索引鍵", "主索引鍵", "非叢集索引"], "answer": [2], "explanation": "這題的關鍵在於確保兩個資料表之間的「關聯」與「資料完整性」。外\n部索引鍵 (Foreign Key) 的核心用途，就是建立一個資料表(例如 Sales)對另一個資\n料表(例如 SalesPerson)的參考，強制參考的資料必須存在。如此一來，可以防止在\nSales 資料表中新增一筆不存在的銷售人員所賣出的訂單，確保了資料的正確性與\n一致性。\n(A) 叢集索引是定義資料在磁碟上的實體儲存順序，與資料關聯的正確性無關。\n(C) 主索引鍵是用來確保「自己資料表」中每一筆資料的唯一性，而非用於關聯兩個\n不同的資料表。\n(D) 非叢集索引是用來加速查詢，與資料關聯的正確性無關。在這個案例中，它能\n確保 Sales 資料表中的每一筆記錄都對應到 SalesPerson 資料表中一個實際存在的\n銷售人員", "image": null, "type": "single"}, {"id": 2, "question": "2. 您接受了某間地方慈善機構的IT實習工作,該慈善機構的資料模型有兩個資料表,名\n為 Chapter 和 Language,如下所示。\n<br><img src=\"images/2_1.png\" class=\"q-image\"><br>\n<br><img src=\"images/2_2.png\" class=\"q-image\"><br>\n您建立了名為 ChapterLanguage 的第三個資料表來關聯 Chapter 資料表和\nLanguage 資料表。\n您需要從 Chapter 和 Language 資料表中選取資料行,以便為 ChapterLanguage 資\n料表建立複合主索引鍵。\n請問您應該選取哪兩個資料行?(請選擇2個答案)", "options": ["ChapterId", "City", "Region", "Country", "LanguageId", "LanguageName"], "answer": [1, 5], "explanation": "複合主索引鍵 (Composite Primary Key) 是由兩個或多個欄位組成的索引鍵，用於\n唯一識別資料表中的每一筆記錄。\n為了關聯 Chapter 和 Language 這兩個資料表，我們需要選取它們各自的主索引鍵\n，也就是 ChapterId 和 LanguageId，作為新資料表 ChapterLanguage 的複合主\n索引鍵。", "image": null, "type": "multiple"}, {"id": 3, "question": "3. 您正在設定關聯式資料庫中某個資料表的結構。對於下列每一項敘述,若[正確]為\n○,[錯誤]為X。\n①資料表中欄位的每個值都必須是唯一的。\n②資料表中的每個資料列都必須是唯一的。\n③ 資料表中的每個資料行名稱都必須是唯一的。\n請問填入正確或錯誤符號順序為何?", "options": ["X、X、○", "X、○、X", "X、○、○", "○、○、X"], "answer": [3], "explanation": "①錯誤 (X): 資料表中欄位的每個值不一定都是唯一的。只有主索引鍵或設定唯一條\n件約束的欄位才需要是唯一的。\n②正確 (〇): 在關聯式資料庫中，每個資料列 (Row) 必須是唯一的，這是由主索引鍵\n確保的。\n③正確 (〇): 資料表中的每個資料行 (Column) 名稱必須是唯一的，以避免在查詢和\n操作時產生歧義。", "image": null, "type": "single"}, {"id": 4, "question": "4. 您的資料庫有一個 Department 資料以及一個 Employee 資料表。您需要確保一\n位員工只能被借派到一個現有的部門。\n請問您應該對 Employee 資料表套用什麼?", "options": ["資料類型", "外部索引鍵", "索引", "主索引鍵", "唯一條件約束"], "answer": [2], "explanation": "為了確保 Employee 資料表中的員工記錄只能關聯到 Department 資料表中一個現\n有的部門，需要在 Employee 資料表上建立一個外部索引鍵，該索引鍵參照\nDepartment 資料表的主索引鍵。\n這會強制實施部門與員工之間的一對多關聯性，確保每位員工都分配給一個有效的\n部門。\nCH02", "image": null, "type": "single"}, {"id": 1, "question": "1. 您有一個名為Customer 的資料表。您需要建立一個名為 District 的新資料行。\n請問您應該使用哪一個陳述式?", "options": ["ALTER TABLE Customer ADD (INTEGER District)", "ALTER TABLE Customer ADD (District INTEGER)", "MODIFY TABLE Customer ADD (INTEGER District)", "ALTER TABLE Customer MODIFY (District INTEGER)"], "answer": [2], "explanation": "ALTER TABLE 陳述式用於修改現有的資料表結構，而 ADD 子句則用於新增欄位。\n正確的語法是 ALTER TABLE table_name ADD (column_name data_type)。", "image": null, "type": "single"}, {"id": 2, "question": "2. 您有一個名為Product 的資料表。您建立了一個檢視表,其中包含 Product 資料中\n屬於 Furniture 類的所有產品。\n您針對 Product 資料表執行一個陳述式來刪除屬於 Furniture 類別的所有產品。\n在您執行該陳述式之後,檢視表的結果集將:", "options": ["被封存", "被刪除", "清空", "保持不變"], "answer": [3], "explanation": "檢視表 (View) 是一個虛擬資料表，它不儲存實際資料，而是根據其定義的查詢動態\n產生結果集。\n當您從基礎資料表 Product 中刪除所有 Furniture 類別的產品時，檢視表在下次被\n查詢時將找不到任何符合條件的資料，因此結果集將會清空。", "image": null, "type": "single"}, {"id": 3, "question": "3. 函數與預存程序之間的其中一項差異在於,函數:", "options": ["必須有傳回值", "無法接受參數", "無法包含交易", "必須由觸發程序呼叫"], "answer": [1], "explanation": "函數 (Function) 必須傳回一個值，而預存程序 (Stored Procedure) 則不一定需要。\n預存程序可以執行多個 SQL 陳述式，並可以傳回多個結果集或沒有任何結果。", "image": null, "type": "single"}, {"id": 4, "question": "4. 您有一個名為Employee 的資料表,其中包含下列資料行: EmployeelD、\nEmployeeName。請問您應該使用哪一個陳述式來傳回資料表中的資料列數目?", "options": ["SELECT COUNT(rows) FROM Employee", "SELECT COUNT(*) FROM Employee", "SELECT * FROM Employee", "SELECT SUM(*) FROM Employee"], "answer": [2], "explanation": "COUNT(*) 是一個聚合函數，用於計算資料表中的所有資料列數目，包括包含\nNULL 值的資料列。\nCOUNT(rows) 和 SUM(*) 不是標準的 SQL 語法，SELECT * FROM Employee 則是\n返回所有資料列和欄位，而不是資料列的數量。", "image": null, "type": "single"}, {"id": 5, "question": "5. 您刪除了order資料表中的資料列,orderltem 資料表中的對應資料列也被自動刪\n除了。\n這是下列其中一種程序的範例:", "options": ["串聯刪除 (Cascade Delete)", "骨牌法刪除 (Dominoe Delete)", "函數法刪除 (Functional Delete)", "繼承法刪除 (Inherited Deete)", "瀑布法刪除 (Waterfall Delete)"], "answer": [1], "explanation": "串聯刪除 (Cascade Delete) 是外部索引鍵約束的一個屬性。當我們在定義外部索引\n鍵時，可以設定 ON DELETE CASCADE。\n這表示當主資料表（父資料表，如 order）中的一筆資料被刪除時，參考到這筆資\n料的從屬資料表（子資料表，如 orderltem）中的所有對應資料列也會被自動刪除\n，以維持資料的參考完整性。", "image": null, "type": "single"}, {"id": 6, "question": "6. 請問哪一個陳述式會建立複合鍵?", "options": ["CREATE TABLE Order ( OrderID INTEGER, OrderItemID INTEGER, PRIMARY KEY (OrderID, OrderltemID))", "CREATE TABLE Order ( OrderID INTEGER PRIMARY KEY, Order Itemid INTEGER PRIMARY KEY)", "CREATE TABLE Order ( OrderID INTEGER, OrderItemID INTEGER, PRIMARY KEY)", "CREATE TABLE Order ( OrderID INTEGER, OrderltemID INTEGER, PRIMARY KEY OrderID, PRIMARY KEY OrderitemID)"], "answer": [1], "explanation": "複合鍵 (Composite Key) 是指由兩個或多個欄位共同組成的主索引鍵。其建立語法\n是在所有欄位定義完之後，使用 PRIMARY KEY (欄位1, 欄位2, ...) 的形式來指定。\n選項 (A) 正確地使用了此語法。\n(B) 和 (D) 的語法是錯誤的，一個資料表只能有一個主索引鍵。\n(C) 的語法不完整，PRIMARY KEY 後面沒有指定任何欄位。", "image": null, "type": "single"}, {"id": 7, "question": "7. 一位開發人員嘗試使用下列查詢,在資料表中新增一個名為Prefix 資料行:\nALTER TABLE Person ADD Prefix varchar(4) NOT NULL;\n這位開發人員在執行查詢之後收到錯誤訊息。但是,這位開發人員無法記住確切的錯\n誤訊息。請問這個問題的可能原因為何?", "options": ["應該使用DEFAULT 關鍵字來指定預設值", "varchar(4)資料類型不適用於Person 資料表", "應該先執行 DROP CONSTRAINT 查詢,再執行 ALTER TABLE 查詢", "Person 資料表是空的"], "answer": [1], "explanation": "當一個已經存在資料的資料表要新增一個設定為 NOT NULL (不允許空值) 的欄位時\n，資料庫會遇到一個問題：對於那些已經存在的資料列，這個新欄位的值應該是什\n麼？因為不允許是 NULL，所以必須為這些舊資料列提供一個預設值。如果沒有使\n用 DEFAULT 關鍵字指定一個預設值，這個 ALTER TABLE 操作就會失敗。如果資料\n表是空的，這個操作則會成功。", "image": null, "type": "single"}, {"id": 8, "question": "8. 您在某間咖啡廳工作,公司要求您設定網站來儲存購物費用。您需要建議公司在資\n料庫資料表中使用某種資料類型,以便根據收費金額執行財務函數。\n請問您應該使用哪一種資料類型?", "options": ["binary", "bit", "decimal", "varchar"], "answer": [3], "explanation": "在處理金錢、貨幣等需要高精確度的數值時，應該使用 decimal (或 numeric,\nmoney) 這類固定小數點的資料類型。這可以避免使用 float 等浮點數資料類型時可\n能發生的微小誤差，確保財務計算的準確性。\n(A) binary 用於儲存二進位資料。\n(B) bit 用於儲存 0 或 1 的布林值。\n(D) varchar 用於儲存字串。", "image": null, "type": "single"}, {"id": 9, "question": "9. 您正在建立一個名為Student 的資料庫物件儲存以下資料:\n<br><img src=\"images/9_3.png\" class=\"q-image\"><br>\n請問您應該使用哪一個語法來建立物件?", "options": ["CREATE TABLE Student( ID INT, Name VARCHAR (100), Age INT)", "CREATE Student ( ID INT, Name VARCHAR (100), Age INT)", "CREATE ( TABLE StudentID INT, Name VARCHAR (100), Age INT)", "CREATE TABLE ( ID INT, Name VARCHAR (100), Age INT)"], "answer": [1], "explanation": "建立資料表的標準 SQL 語法是 CREATE TABLE 資料表名稱 (欄位1 資料型態, 欄位2\n資料型態, ...);。選項 (A) 完全符合這個語法結構。\n(B) 缺少了 TABLE 關鍵字。\n(C) 和 (D) 的括號位置不正確。", "image": null, "type": "single"}, {"id": 10, "question": "10. 您需要利用下面的程式碼設定一個資料庫來提供北美哺乳動物的檢視表\n(NorthAmericaMammals View):\n①\n②\n③\nWHERE a.Class = 'Mammals' AND a.InNorthAmerica = 1\n請將下方A~F的程式碼片段排列到上方缺失的正確位置。每個程式碼片段可能只使\n用一次,也可能使用多次,甚至完全用不到。\nA. CREATE VIEW [dbo].[NorthAmericaMammals_View]\nB. INSERT VIEW [dbo].[NorthAmericaMammals_View]\nC. AS JOIN a.Id, a. Name\nD. AS SELECT a.Id, a.Name\nE. FROM Animal a\nF. JOIN Animals a\n請問填入的程式碼片段順序為何?", "options": ["A、C、F", "A、D、E", "B、D、E", "B、C、F"], "answer": [2], "explanation": "建立檢視表的完整語法是 CREATE VIEW 檢視表名稱 AS SELECT 欄位... FROM 資料\n表... WHERE 條件...;。\n因此，正確的順序是：", "image": null, "type": "single"}, {"id": 1, "question": "1. CREATE VIEW [dbo].[NorthAmericaMammals_View] (A)", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 2, "question": "2. AS SELECT a.Id, a.Name (D)", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 3, "question": "3. FROM Animal a (E)", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 4, "question": "4. WHERE a.Class = 'Mammals' AND a.InNorthAmerica = 1 (題目已給定)\n所以組合起來是 A、D、E。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 11, "question": "11. 對於下列每一項敘述,若[正確]為○,[錯誤]為X。\n① 您可以使用預存程序來刪除資料。\n② 函數必須具有傳回值。\n③ 預存程序必須具有傳回值。\n請問填入正確或錯誤符號順序為何?", "options": ["X、○、○", "○、○、X", "X、X、○", "○、○、X"], "answer": [4], "explanation": "① 正確(○): 預存程序是一系列的 SQL 陳述式集合，當然可以包含 DELETE 陳述式\n來刪除資料。\n② 正確(○): 這是函數與預存程序最主要的區別之一。函數被設計來計算並傳回一個\n值。\n③ 錯誤(X): 預存程序「可以」透過輸出參數或傳回碼來傳回值，但並非「必須」。\n它可以只執行操作而不傳回任何東西。\n因此，順序為 ○、○、X。", "image": null, "type": "single"}, {"id": 12, "question": "12. 請問哪一個陳述式會從資料表中移除所有資料列,但不記錄個別資料列刪除動作?", "options": ["ALTER TABLE", "DROP TABLE", "TRUNCATE TABLE", "CREATE TABLE"], "answer": [3], "explanation": "TRUNCATE TABLE 指令用於快速刪除一個資料表中的所有資料列。與 DELETE 不同\n，TRUNCATE 通常是一個最小化日誌記錄的操作，它不會為每一筆被刪除的資料列\n寫入交易日誌，因此執行速度非常快。但這也意味著它通常不能被輕易地復原\n(rollback)，且不會觸發 DELETE 觸發器。\n(A) ALTER TABLE 用於修改資料表結構。\n(B) DROP TABLE 會刪除整個資料表，包括其結構和資料。", "image": null, "type": "single"}, {"id": 13, "question": "13. 請問關聯式資料庫會使用哪一項功能來確保輸入資料行中的資料有效?", "options": ["屬性", "主索引鍵", "條件約束", "索引"], "answer": [3], "explanation": "條件約束 (Constraint) 是資料庫用來強制執行資料完整性規則的主要機制。它包含\n了多種類型，例如：\n* NOT NULL: 確保欄位不能是空值。\n* UNIQUE: 確保欄位中的值是唯一的。\n* PRIMARY KEY: 主索引鍵約束 (是 NOT NULL 和 UNIQUE 的結合)。\n* FOREIGN KEY: 外部索引鍵約束，確保參考完整性。\n* CHECK: 確保欄位中的值符合指定的條件。\n這些約束共同確保了輸入資料的有效性。", "image": null, "type": "single"}, {"id": 14, "question": "14. 您需要從資料庫中移除名為Employeeview 的檢視表。請問您應該使用哪一個\n陳述式?", "options": ["DELETE EmployeeView", "DELETE VIEW EmployeeView", "DROP EmployeeView", "DROP VIEW EmployeeView"], "answer": [4], "explanation": "檢視表、資料表、索引等都屬於資料庫的「物件」。\n要移除這些物件，應使用 DDL (資料定義語言) 中的 DROP 指令。其標準語法為\nDROP VIEW 檢視表名稱;。\n(A) 和 (B) 的 DELETE 是 DML (資料操作語言)，用於刪除資料表中的「資料列」，\n而不是物件本身。", "image": null, "type": "single"}, {"id": 15, "question": "15. 建立預存程序的其中一個原因是要:", "options": ["提升效能", "將儲存空間最小化", "略過區分大小寫需求", "讓使用者能夠控制查詢邏輯"], "answer": [1], "explanation": "預存程序 (Stored Procedure) 有多個優點，其中最主要的一個是「提升效能」。因\n為預存程序是預先編譯好並儲存在資料庫伺服器上，當被呼叫時，資料庫無需重新\n解析和編譯 SQL 陳述式，減少了網路傳輸量和伺服器的處理負擔，從而提升了執行\n效率。", "image": null, "type": "single"}, {"id": 16, "question": "16. 請問您應該使用哪一個陳述式來移除外部索引鍵?", "options": ["ALTER TABLE", "DELETE TABLE", "ALTER FOREIGN KEY", "DELETE FOREIGN KEY"], "answer": [1], "explanation": "外部索引鍵是一個資料表的「條件約束」，屬於資料表結構的一部分。要修改資料\n表的結構（包括新增、刪除或修改條件約束），都必須使用 ALTER TABLE 陳述式。\n通常的語法會是 ALTER TABLE 資料表名稱 DROP CONSTRAINT 約束名稱;。", "image": null, "type": "single"}, {"id": 17, "question": "17. 您的公司將客戶的社會安全號碼儲存在 Customers 資料表的SSN 資料行中。但\n是,新的法規禁止公司儲存這些資訊。\n執行下列查詢會導致系統發生錯誤。\nALTER TABLE Customers\nREMOVE SSN;\n請問您需要對上述查詢進行哪些變更,才能讓它從Customers 資料表中移除 N資料行?", "options": ["ALTER TABLE Customers DROP COLUMN SSN;", "ALTER TABLE Customers DELETE COLUMN", "ALTER TABLE Customers DROP SSN;", "ALTER TABLE Customers DELETE SSN;"], "answer": [1], "explanation": "在標準 SQL 中，要從資料表中移除一個資料行，應使用 ALTER TABLE 陳述式搭配\nDROP COLUMN 子句。選項 (A) 是最標準且正確的語法。\nREMOVE 或 DELETE 都不是用來刪除資料行的標準關鍵字。", "image": null, "type": "single"}, {"id": 18, "question": "18. 您需要刪除某個資料庫資料表。請問您應該使用哪一個資料定義語言(DDL) 關鍵\n字?", "options": ["ALTER", "TRUNCATE", "DROP", "DELETE"], "answer": [3], "explanation": "DDL (資料定義語言) 用於定義或管理資料庫物件的結構。要「刪除整個資料表」（\n包括其結構、資料和相關索引），應使用 DROP 關鍵字。語法為 DROP TABLE 資\n料表名稱;。\n(A) ALTER 用於修改結構。\n(B) TRUNCATE 用於刪除所有資料，但保留結構。\n(D) DELETE 是 DML，用於刪除資料列，同樣保留結構。", "image": null, "type": "single"}, {"id": 19, "question": "19. 有一個資料庫資料表儲存了學校出勤率的相關資訊,資料集定義如下:\n<br><img src=\"images/19_4.png\" class=\"q-image\"><br>\n您有下列需求:\n* StudentName 必須包含字元字串。\n* GradeLevel 必須是整數。\n* DaysAbsent可以在小數點後面包含一位數字。\n可使用的資料類型是:", "options": ["BIT", "DECIMAL", "VARCHAR", "DATETIME", "INT", "CHAR StudentName、GradeLevel 及DaysAbsent 的資料類型為何?", "C、E、B", "C、B、E", "F、E、B", "A、B、B"], "answer": [1], "explanation": "* StudentName: 儲存姓名，是字元字串，應使用 VARCHAR (C) 或 CHAR (F)。\nVARCHAR 更常用，因為它是可變長度。\n* GradeLevel: 儲存年級，是整數，應使用 INT (E)。\n* DaysAbsent: 儲存缺席天數，需要支援小數（如 2.5），應使用 DECIMAL (B)。\n組合起來，最合理的選擇是 VARCHAR, INT, DECIMAL，對應到 (C), (E), (B)。所以\n答案是 (A)。", "image": null, "type": "single"}, {"id": 20, "question": "20. 您正在開發一個SQL 陳述式以建立資料表。請問哪兩個 SQL 關鍵字可用於\nCREATE TABLE 陳述式?(請選擇2個答案)", "options": ["ORDER BY", "CONSTRAINT", "PRIMARY KEY", "INSERT INTO"], "answer": [2, 3], "explanation": "在 CREATE TABLE 陳述式中，我們定義資料表的欄位以及確保資料完整性的規則。\n* CONSTRAINT (B) 是用來定義各種約束的通用關鍵字，例如 CHECK, UNIQUE,\nPRIMARY KEY, FOREIGN KEY。\n* PRIMARY KEY (C) 是最重要的一種約束，可以直接在欄位後定義，也可以透過\nCONSTRAINT 關鍵字來定義。\n(A) ORDER BY 用於 SELECT 查詢的排序。\n(D) INSERT INTO 用於新增資料。", "image": null, "type": "multiple"}, {"id": 21, "question": "21. 您建立了一個名為 Games 的資料,其中包含最近發行之電玩遊戲的評論分數。\n您需要建立一個檢視表來傳回按照字母順序排列的遊戲名稱清單。Name 代表遊戲\n名稱。請問您應該使用哪一個查詢?", "options": ["CREATE VIEW MyGames AS SELECT Name FROM Games", "CREATE VIEW MyGames AS SELECT * FROM Games", "CREATE VIEW MyGames AS SELECT Name FROM Games ORDER BY Name", "CREATE VIEW MyGames AS SELECT * from Games WHERE Name BETWEEN 'A' AND 'Z'"], "answer": [3], "explanation": "題目的要求是「按照字母順序排列」。\n在 SQL 中，要對查詢結果進行排序，必須使用 ORDER BY 子句。因此，在建立檢\n視表的 SELECT 陳述式中，需要包含 ORDER BY Name。", "image": null, "type": "single"}, {"id": 22, "question": "22. 您撰寫了一系列執行冗長複雜查詢的SQL 陳述式。這些陳述式會透過電子郵件\n傳送結果。\n您希望能夠在需要時隨時手動呼叫程式碼。請問您可以使用哪一個資料庫物件來儲\n存程式碼?", "options": ["預存程序", "函數", "檢視表", "觸發程序"], "answer": [4], "explanation": "預存程序 (Stored Procedure) 就是被設計來儲存一系列可重複使用的 SQL 陳述式。\n它可以接受參數、執行複雜的邏輯、並可由使用者或應用程式「手動呼叫」。這完\n全符合題目的需求。\n(B) 函數主要用於傳回單一值。\n(C) 檢視表主要用於簡化查詢。\n(D) 觸發程序是自動執行的，不能手動呼叫。\nCH03\n1.您有兩個資料表,每個資料表都有三個資料列。建立了一個使用交叉聯結的 SQL 查\n詢,這個查詢不包含WHERE子句。\n請問這兩個資料表的笛卡兒乘積會包含多少個資料列?\n(A) 0 (B) 3\n(C) 6 (D) 9\n\n交叉聯結 (CROSS JOIN) 會產生兩個資料表的「笛卡兒乘積」。這意味著第一個資\n料表的每一筆資料列，都會與第二個資料表的每一筆資料列進行配對。\n因此，結果集的總資料列數會是第一個資料表的資料列數「乘以」第二個資料表的\n資料列數。在這個例子中，就是 3 * 3 = 9。", "image": null, "type": "single"}, {"id": 2, "question": "2. 您執行了下列查詢:\nSELECT EmployeeID, FirstName, DepartmentName\nFROM Employee, Department\n這種作業稱為:", "options": ["笛卡兒乘積 (B) 等聯結", "交集 (D) 外部聯結"], "answer": [1], "explanation": "在 FROM 子句中直接列出多個資料表，而沒有使用 WHERE 或 JOIN...ON 子句來指\n定它們之間的關聯條件時，資料庫會執行交叉聯結，產生笛卡兒乘積。\n這是比較舊的 SQL-89 語法，現在建議使用明確的 CROSS JOIN 關鍵字。", "image": null, "type": "single"}, {"id": 3, "question": "3. 請問哪一個查詢會傳回除了加州(CA)以外,其他所有州在2017年1月之後提交之單\n的結果集?", "options": ["SELECT * FROM orders WHERE order_date > '2017-01-01' AND ship_state LIKE 'CA'", "SELECT * FROM orders WHERE order_date > '2017-01-01' AND ship_state <> 'CA'", "SELECT * FROM orders WHERE order_date > '2017-01-01' OR ship_state <> 'CA'", "SELECT * FROM orders WHERE order_date > '2017-01-01' OR ship_state LIKE 'CA'"], "answer": [2], "explanation": "題目要求兩個條件「同時」成立：", "image": null, "type": "single"}, {"id": 1, "question": "1. 訂單日期在 '2017-01-01' 之後 (order_date > '2017-01-01')。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 2, "question": "2. 運送州別「不是」CA (ship_state <> 'CA')。<> 是 SQL 中「不等於」的運算子。\n因為兩個條件要同時滿足，所以必須使用 AND 來連接它們。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 4, "question": "4. 您需要針對 students 資料表中的資料建立一份報表。此報表必須符合下列需求:\nA.顯示在2020年6月1日當天或之後註冊的所有學生\nB.顯示在2020年畢業的所有學生\nC.按照註冊順序傳回結果集,最新的註冊日期列在第一個\nerrollment_date 會指定註冊日期。graduation_date 會指定畢業日期。\n如果 academic_status 是 Graduated,就表示學生畢業。請問您應該使用哪一個查\n詢?", "options": ["SELECT * FROM students WHERE enrollment_date >= '2020-06-01' OR academic_status='Graduated' OR graduation_date >= '2020-01-01' ORDER BY enrollment_date DESC", "SELECT * FROM students WHERE enrollment_date >= '2020-06-01' AND academic_status='Graduated' AND graduation_date >= '2020-01-01' ORDER BY enrollment_date ASC", "SELECT * FROM students WHERE enrollment_date >= '2020-06-01' OR academic_status='Graduated' AND graduation_date >= '2020-01-01' ORDER BY enrollment_date DESC", "SELECT * FROM students WHERE errollment_date >= '2020-06-01' AND academic_status='Graduated' OR graduation_date >= '2020-01-01' ORDER BY enrollment_date"], "answer": [3], "explanation": "這題的需求是 A「或」B，也就是符合 A 或 B任一條件的學生都要顯示，所以要用\nOR。\n條件是 enrollment_date >= '2020-06-01' OR (academic_status='Graduated'\nAND graduation_date >= '2020-01-01')。\n同時，要求最新的註冊日期排在最前面，所以要用 ORDER BY enrollment_date\nDESC (DESC 代表遞減排序)。選項 (C) 的邏輯最符合這些要求。", "image": null, "type": "single"}, {"id": 5, "question": "5. 請問哪一個SQL陳述式會傳回訂單數目少於50的國家地區以及各國家地區的訂單\n數目?\norderID 代表個別訂單、Country 代表國家地區,而orders 代表訂單數目。", "options": ["SELECT COUNT(orderID), Country FROM Orders GROUP BY Country HAVING COUNT(orderID) < 50;", "SELECT Country, orderID FROM Orders WHERE COUNT(orderID) < 50; GROUP BY Country;", "SELECT COUNT(orderID), Country FROM Orders HAVING COUNT(orderID) < 50; GROUP BY Country", "SELECT Country, orderID FROM Orders GROUP BY Country WHERE COUNT(orderID) < 50;"], "answer": [1], "explanation": "這題的關鍵是要對「彙總函式的結果」進行篩選。\nWHERE 子句是在分組和彙總「之前」對個別資料列進行篩選。\n而 HAVING 子句則是在 GROUP BY 分組和彙總「之後」對分組結果進行篩選。因\n為我們要篩選的是 COUNT(orderID) < 50，所以必須使用 HAVING 子句。", "image": null, "type": "single"}, {"id": 6, "question": "6. 有一個名為 Playerstat 資料表包含以下欄位:\n<br><img src=\"images/6_5.png\" class=\"q-image\"><br>\n您需要針對 TeamID 為1的隊伍顯示每位隊員的總分數,程式碼如下:\nSELECT PlayerID, (1)\nFROM PlayerStat (2) TeamID = 1\n(3) (4)\n請將下方A~G的程式碼片段排列到上方缺失的正確位置。\n每個程式碼片段可能只使用一次,也可能使用多次,甚至完全用不到。\nA. PlayerID B. COUNT C. GROUP BY\nD. TeamID E. WHERE F. SUM(Points)\nG. HAVING\n請問填入的程式碼片段順序為何?", "options": ["F、C、D、B", "D、C、E、F", "F、E、C、A", "B、E、F、D"], "answer": [3], "explanation": "這個查詢的目的是：", "image": null, "type": "single"}, {"id": 1, "question": "1. 計算總分，所以 (1) 應填入 SUM(Points) (F)。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 2, "question": "2. 篩選出 TeamID 為 1 的隊伍，所以 (2) 應填入 WHERE (E)。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 3, "question": "3. (3) 已經給定條件 TeamID=1。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 4, "question": "4. 要「每位」隊員的總分，代表要根據 PlayerID 進行分組，所以 (4) 應填入\nGROUP BY PlayerID (C, A)。\n組合起來的順序是 F, E, C, A", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 7, "question": "7. 您是某間大學的資料庫管理員,該大學將學生資訊儲存在一個名為students 的資料\n中。\n這個資料表具有一個名為 courseID 的外部索引鍵,可連結至 courses 資料表中的主\n索引鍵。\n您需要使用這兩個根據 courseID 配對的資料表來傳回學生姓名和課程名稱。\n您執行了下列查詢:\nSELECT students.name, courses.name\nFROM students OUTER JOIN courses\nWHERE student.courseID = courses.courseID\n此查詢會傳回錯誤。\n請問您該如何修正查詢?", "options": ["SELECT students.Name, courses.Name FROM students INNER JOIN ON courses WHERE students.courseID = courses.CourseID", "SELECT students.name, courses.name FROM students INNER JOIN courses ON students.courseID = courses.courseID", "SELECT students.name, courses.name FROM students INNER JOIN ON students.courseID = courses.courseID", "SELECT students.name, courses.name FROM students INNER JOIN courses WHERE students.courseID = courses.courseID"], "answer": [2], "explanation": "現代的 SQL (SQL-92 標準) 建議使用明確的 JOIN 語法。JOIN 的關聯條件應該使用\nON 關鍵字來指定，而不是放在 WHERE 子句中。OUTER JOIN 是一個不完整的語\n法，應該明確指定是 LEFT OUTER JOIN, RIGHT OUTER JOIN 還是 FULL OUTER\nJOIN。但此題的重點在於 JOIN 的語法結構，正確的結構是 FROM table1 JOIN\ntable2 ON table1.key = table2.key。選項 (B) 是唯一符合此結構的。", "image": null, "type": "single"}, {"id": 8, "question": "8. 有一個預存程序包含以下查詢:\nSELECT 'Greetings' + Prefix + FirstName FROM Person;\n此預存程序會傳回所有 null值。您確認 Person 資料表包含資料。\n請問這個問題的可能原因為何?", "options": ["Prefix 或FirstName 資料行具有null值。", "您必須在查詢中 指定 NULLIF 關鍵字。", "加號(+)運算子無法用來附加字元資料。", "您必須在SELECT 陳述式中指定 JOIN 關鍵字。"], "answer": [1], "explanation": "在大多數的 SQL 資料庫系統中（如 SQL Server），當你使用 + 運算子來串接字串\n時，只要其中任何一個部分是 NULL，整個串接的結果就會是 NULL。因此，如果\nPrefix 或 FirstName 欄位中有任何一筆資料是 NULL，該筆資料列的查詢結果就會\n是 NULL。", "image": null, "type": "single"}, {"id": 9, "question": "9. 請問哪一個關鍵字會結合兩個查詢的結果並且僅傳回兩個結果集都有出現的資料\n列?", "options": ["UNION", "INTERSECT", "ALL", "JOIN"], "answer": [2], "explanation": "INTERSECT (交集) 運算子會比較兩個 SELECT 陳述式的結果集，並只傳回在「兩個」\n結果集中都存在的資料列。它會自動移除重複的資料列。\n(A) UNION (聯集) 會傳回兩個結果集中的所有資料列，並移除重複項。", "image": null, "type": "single"}, {"id": 10, "question": "10. 有一個名為Cars 的資料庫資料表,其定義如下所示。\n<br><img src=\"images/10_6.png\" class=\"q-image\"><br>\n您設有下列SQL 陳述式:\nSELECT *\nFROM Cars c\nWHERE c. Origin <> 'USA' AND c.Color <> 'Black'\n請問此 SQL 陳述式會傳回多少個資料列?", "options": ["4", "5", "6", "7"], "answer": [1], "explanation": "我們來逐步篩選：", "image": null, "type": "single"}, {"id": 1, "question": "1. 原始資料共 8 筆。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 2, "question": "2. 第一個條件 c.Origin <> 'USA' (產地不是美國) 會排除掉 Truck 和 Convertible。\n剩下 6 筆。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 3, "question": "3. 第二個條件 c.Color <> 'Black' (顏色不是黑色) 會從剩下的 6 筆中，再排除掉\nCompact 和 Hybrid。剩下 4 筆。\n因為兩個條件是用 AND 連接，所以必須同時滿足。最終結果是 4 筆。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 11, "question": "11. 您需要將兩個查詢的結果結合成單一結果,而且包含這兩個查詢中的所有資料列。\n請問您應該使用哪一個SQL述式?", "options": ["EXCEPT", "JOIN", "TRUNCATE", "UNION"], "answer": [4], "explanation": "UNION (聯集) 運算子就是用來將兩個或多個 SELECT 陳述式的結果集合併成一個單\n一的結果集。UNION 預設會移除重複的資料列。如果想要保留所有重複的資料列\n，可以使用 UNION ALL。", "image": null, "type": "single"}, {"id": 12, "question": "12. 您有一個儲存客戶相關資訊的 customer 資料表,以及一個儲存已提交訂單相關\n資訊的 order 資料表。\n每個資料表都包含一個customerID 資料行,您使用個別資料表中的Customer 資料\n行來聯結這兩個資料表。\n您執行了一個選取下列資料的查詢:\n* 所有客戶及其訂單\n* 沒有任何訂單的客戶\n請問這些結果代表哪一種聯結?", "options": ["完全聯結", "內部聯結", "完全外部聯結", "部分聯結"], "answer": [3], "explanation": "這個描述最精確地對應到 LEFT OUTER JOIN (左外部聯結)，假設 customer 是左邊\n的資料表。它會傳回所有左邊資料表(customer)的紀錄，以及右邊資料表(order)中\n匹配的紀錄。如果某個客戶沒有訂單，則訂單相關的欄位會顯示為 NULL。而 FULL\nOUTER JOIN (完全外部聯結) 會包含 LEFT JOIN 的所有結果，再加上「有訂單但沒\n有對應客戶」的紀錄（在有外部索引鍵約束下，這種情況不應發生）。在此選擇題\n中，完全外部聯結 是最接近且包含所需結果的選項。", "image": null, "type": "single"}, {"id": 13, "question": "13. 您 其中包含名為CustomerID、Firstname 和 Date Joined 資料列。\nCustomerID 是主索引鍵。\n您執行了下列查詢:\nSELECT CustomerID, FirstName, Date Joined\nFROM Customer\n請問結果集會以哪種方式組織資料列?", "options": ["按照無法預測的順序", "按照 FirstName 的字母序", "按照 DateJoined 的時間序", "按照插入資料列的順序"], "answer": [1], "explanation": "關聯式資料庫的理論基礎是集合論，集合中的元素是沒有固定順序的。因此，如果\n一個 SELECT 查詢沒有明確使用 ORDER BY 子句來指定排序方式，資料庫回傳資料\n的順序是「不被保證的」。它可能會因為查詢計畫、索引、或資料的實體儲存方式\n而改變，所以是無法預測的。", "image": null, "type": "single"}, {"id": 14, "question": "14. 您正在撰寫一個 SELECT 陳述式找出名稱包含特定字元的所有產品。\n請問您應該在 WHERE子句中使用哪一個關鍵字?", "options": ["LIKE", "FETCH", "BETWEEN", "IN"], "answer": [1], "explanation": "LIKE 運算子專門用於字串的比對，可以搭配萬用字元來進行模糊搜尋。\n* %: 代表零個或多個任意字元。\n* _: 代表一個任意字元。\n例如 WHERE ProductName LIKE '%apple%' 可以找出名稱中包含 'apple' 的所有\n產品。", "image": null, "type": "single"}, {"id": 15, "question": "15. 請問哪一個查詢會正確傳回 ship_state 不含德州 (TX) 和亞利桑那州 (AZ) 之所\n有訂單的結果集?", "options": ["SELECT * FROM Orders WHERE NOT ship_state = 'TX' OR NOT ship_state = 'AZ'", "SELECT * FROM Orders WHERE NOT ship_state = 'TX' AND NOT ship_state = 'AZ'", "SELECT * FROM Orders WHERE ship_state NOT = 'TX' OR ship_state NOT = 'AZ'", "SELECT * FROM Orders WHERE ship_state NOT = 'TX' AND ship_state NOT = 'AZ';"], "answer": [2], "explanation": "要同時排除 TX 和 AZ，條件必須是「州不等於 TX」『而且』「州不等於 AZ」。所\n以必須使用 AND 來連接這兩個條件。如果使用 OR，那麼德州的訂單會因為「不等\n於 AZ」而滿足條件被選出來，反之亦然，這就不對了。正確的邏輯是 WHERE\nship_state <> 'TX' AND ship_state <> 'AZ'，或是 WHERE ship_state NOT IN\n('TX', 'AZ')。選項 (B) 的 NOT ... AND NOT ... 在邏輯上是正確的。\nCH04", "image": null, "type": "single"}, {"id": 1, "question": "1. 您有一個名為Student 的資料表,其中包含100個資料列。\n部分資料列 Firstname 資料行具有NULL值,您執行了下列陳述式:\nDELETE FROM Student\n請問結果為何?", "options": ["您會收到錯誤訊息", "系統將刪除資料表中的所有資料列", "系統將刪除所有資料列和資料表定義", "系統將刪除 Firstname 資料行含有NULL 值的所有資料列"], "answer": [2], "explanation": "DELETE FROM [資料表名稱] 陳述式如果沒有加上 WHERE 子句來指定條件，它的\n預設行為就是刪除該資料表中的「所有」資料列。這個操作不會影響資料表的結構\n定義。", "image": null, "type": "single"}, {"id": 2, "question": "2. 您的資料庫包含一個名為Customer的資料表。您需要從Customer資料表中刪除\nCustomerID為12345的記錄。\n請問您應該使用哪一個陳述式?", "options": ["DELETE FROM Customer WHERE CustomerID = 12345", "DELETE Customer ID FROM Customer WHERE CustomerID = 12345", "UPDATE Customer DELETE * WHERE CustomerID = 12345", "UPDATE Customer ID FROM Customer DELETE * WHERE CustomerID = 12345"], "answer": [1], "explanation": "選項 (A) 完全符合這個語法。刪除特定資料列的標準 SQL 語法是 DELETE FROM [\n資料表名稱] WHERE [條件];。\n(B) DELETE 後面不需指定欄位名稱。\n(C) 和 (D) 的語法完全錯誤，混用了 UPDATE 和 DELETE。", "image": null, "type": "single"}, {"id": 3, "question": "3. 您有一個名為 Product 的資料表包含以下資料。\n<br><img src=\"images/3_7.png\" class=\"q-image\"><br>\nProductID 資料行是主索引鍵。CategoryID 資料行是名為Category 之個別資料表\n的外部索引鍵。您執行了下列陳述式:\nINSERT INTO Product VALUES (3296, 'Table', 4444) 請問結果為何?", "options": ["語法錯誤", "Product 資料表中的新資料列", "外部索引鍵條件約束違規", "主索引鍵條件約束違規", "Category 資料表中的新資料列"], "answer": [4], "explanation": "主索引鍵 (Primary Key) 的最重要特性就是它的值在資料表中必須是「唯一的」。\n資料表中已經存在一筆ProductID為 3296 的紀錄。\n當我們試圖再INSERT (插入) 一筆ProductID 同樣為 3296 的新紀錄時，就違反了主\n索引鍵的唯一性約束，資料庫會拒絕此操作並回報錯誤。", "image": null, "type": "single"}, {"id": 4, "question": "4. 您有一個資料庫資料表(AddressInfo) 包含以下資料行:\n<br><img src=\"images/4_8.png\" class=\"q-image\"><br>\n您必須在資料表中插入下列記錄:\n<br><img src=\"images/4_9.png\" class=\"q-image\"><br>\n請問您可以使用哪兩個SQL 陳述式?(請選擇2個答案。)", "options": ["INSERT INTO AddressInfo VALUES ('1234 Main Street', 'Dallas', 'TX', ' 75201')", "INSERT INTO Addressinfo ( 1234 Main Street', 'Dallas', 'TX', '75201') VALUES ([StreetAddress], [City], [State], [PostalCode])", "INSERT INTO AddressInfo ([StreetAddress], [City], [State], [PostalCode]) VALUES ('1234 Main Street', 'Dallas', 'TX', '75201')", "UPDATE Addressinfo SET [StreetAddress] = '1234 Main Street', [City] = ' Dallas', [State] = 'TX', [PostalCode] = '75201'"], "answer": [1, 3], "explanation": "1.INSERT INTO [資料表名稱] VALUES (值1, 值2, ...);：這種語法不指定欄位名稱，\n但提供的值必須與資料表中欄位的「原始順序」完全對應。選項 (A) 符合此語法。\n2.INSERT INTO [資料表名稱] (欄位1, 欄位2, ...) VALUES (值1, 值2, ...);：這種語法明\n確指定要插入的欄位及其對應的值，更為安全和清晰。選項 (C) 符合此語法。\n選項 (D) 使用 UPDATE，是用於修改現有資料，而非插入新資料。", "image": null, "type": "multiple"}, {"id": 5, "question": "5. 您接受了某間地方慈善機構的IT實習工作該慈善機構要求您使用一個名為\nVolunteer 的資料庫資料表來保留志工的記錄。\n這個資料表包含以下資料行和資料列:\n<br><img src=\"images/5_10.png\" class=\"q-image\"><br>\n當志工資訊變更時您就必須更新資料表。您需要將 Tia 的名字變更為 Kimberly。請\n問您應該選擇哪一個陳述式?", "options": ["UPDATE Volunteer SET GivenName = 'Kimberly' WHERE Given Name = 'Tia'", "UPDATE GivenName = 'Kimberly' FROM Volunteer WHERE Given Name = 'Tia'", "SET GivenName = 'Kimberly' FROM Volunteer WHERE Given Name = 'Tia'", "SET Volunteer WHERE Given Name = 'Tia'"], "answer": [1], "explanation": "修改現有資料的標準 SQL 語法是 UPDATE [資料表名稱] SET [欄位名稱] = [新值]\nWHERE [條件];。\n*UPDATE Volunteer: 指定要更新的資料表。\n*SET GivenName = 'Kimberly': 指定要將 GivenName 欄位的值設定為 'Kimberly'。\n*WHERE GivenName = 'Tia': 指定要更新的是哪一筆紀錄。\n選項 (A) 完全符合此語法。", "image": null, "type": "single"}, {"id": 6, "question": "6. 請問哪一個SQL 陳述式是資料操作語言(DML) 陳述式?", "options": ["SELECT INTO Employee FROM NewHires", "INSERT INTO Employee VALUES ('Jack Smith');", "ALTER TABLE Employee ADD EmployeeName Varchar;", "SELECT Employee Name FROM Employee WHERE EmployeeName = 'Jack Smith'"], "answer": [2], "explanation": "DML (Data Manipulation Language) 主要用於處理資料表中的「資料」，包括查\n詢和修改。常見的 DML 陳述式有 SELECT, INSERT, UPDATE, DELETE。\n(B) INSERT 是標準的 DML 陳述式，用於新增資料。\n(C) ALTER TABLE 是 DDL (Data Definition Language)，用於修改資料庫物件的結\n構。\n(A) 和 (D) 的 SELECT 也是 DML (或稱 DQL, Data Query Language)。但 INSERT\n是更典型的「操作」語言。在此選項中，B 是最明確的 DML 範例。", "image": null, "type": "single"}, {"id": 7, "question": "7. 您建立了下列名為LoanedBooks 的資料,其中列出您借給朋友的書籍數目。\n<br><img src=\"images/7_11.png\" class=\"q-image\"><br>\n<br><img src=\"images/7_12.png\" class=\"q-image\"><br>\n舊金山的 Harry 歸還了您的書籍。請問哪一個陳述式可正確更新您的資料表?", "options": ["UPDATE LoanedBooks SET Books = 0 WHERE (Name = 'Harry' OR City = ' San Francisco')", "UPDATE LoanedBooks SET Books = 0 WHERE (Name In 'Harry', 'San Francisco')", "UPDATE LoanedBooks SET Books = 0 WHERE (Name = 'Harry' AND City = ' San Francisco')", "INSERT INTO LoanedBooks SET Books = 0 WHERE ID = 4"], "answer": [3], "explanation": "要在一個字串中搜尋是否「包含」某個子字串，應使用 ‘LIKE’ 運算子搭配萬用字\n元 ‘%’。’%’ 代表零個或多個任意字元。所以 ‘LIKE '%chocolate%'‘ 的意\n思是，只要 ‘ItemDescription’ 欄位中的任何位置出現 'chocolate' 這個詞，不\n論前後是否有其他文字，都符合條件。", "image": null, "type": "single"}, {"id": 8, "question": "8. Products 資料表包含以下資料:\n<br><img src=\"images/8_13.png\" class=\"q-image\"><br>\n請問哪一個查詢會在 Item Description 資料行出現 chocolate 時擷取 Item 和\nPrice?", "options": ["SELECT ItemName, Price FROM Products WHERE Item Description LIKE '%chocolate%';", "SELECT ItemName, Price FROM Products WHERE Item Description LIKE 'chocolate';", "SELECT ItemName, Price FROM Products WHERE Item Description IN '%chocolate%';", "SELECT ItemName, Price FROM Products WHERE Item Description = 'chocolate';"], "answer": [1], "explanation": "要在一個字串中搜尋是否「包含」某個子字串，應使用 LIKE 運算子搭配萬用字元 %。\n% 代表零個或多個任意字元。所以 LIKE '%chocolate%' 的意思是，只要\nItemDescription 欄位中的任何位置出現 'chocolate' 這個詞，不論前後是否有其他\n文字，都符合條件。", "image": null, "type": "single"}, {"id": 9, "question": "9. 有一個名為Flight 的資料表包含以下欄位:\n<br><img src=\"images/9_14.png\" class=\"q-image\"><br>\n您需要顯示今天稍晚抵達美國紐約拉瓜迪亞機場(LGA)之所有航班的航班號碼。結果\n應該依照最新的抵達時間來排序,程式碼如下:\nSELECT FlightNumber\nFROM Flight\nWHERE Destination Airport = 'LGA' (1)\nArrival Time (2) GETDATE()\n(3) (4)\n請將下方A~G的程式碼片段排列到上方缺失的正確位置。每個程式碼片段可能只使\n用一次,也可能使用多次,甚至完全用不到。\n① (A) OR (B) AND\n② (A) < (B) > (C) =\n③ (A) GROUP BY (B) ORDER BY\n④ (A) ArrivalTime ASC (B) Arrival Time DESC\n請問填入的程式碼片段順序為何?", "options": ["B、B、B、B", "A、A、A、A", "A、A、B、B", "B、B、A、A"], "answer": [1], "explanation": "這個查詢需要組合多個條件：", "image": null, "type": "single"}, {"id": 1, "question": "1. 目的地是 LGA: WHERE DestinationAirport = 'LGA'。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 2, "question": "2. 抵達時間比現在晚: (1) AND，(2) > GETDATE() (GETDATE() 是取得目前時間的\n函數)。所以 ArrivalTime > GETDATE()。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 3, "question": "3. 依照最新的抵達時間排序: (3) ORDER BY，(4) ArrivalTime DESC (DESC 是遞減\n排序，最新的在最前面)。\n組合起來，順序是 B, B, B, B。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 10, "question": "10. 您有下列資料表定義:\nCREATE TABLE Road\n(RoadID INTEGER NOT NULL,\nDistance INTEGER NOT NULL)\nRoad 資料表包含以下資料:\n<br><img src=\"images/10_15.png\" class=\"q-image\"><br>\n您執行了下列陳述式: INSERT INTO Road VALUES (1234, 36) 請問結果為何?", "options": ["語法錯誤", "資料表中的新資料列", "發生錯誤,指出不允許NULL 值", "發生錯誤,指出不允許重複的ID"], "answer": [2], "explanation": "雖然題目中的 CREATE TABLE 陳述式沒有明確將 RoadID 宣告為 PRIMARY KEY 或\nUNIQUE，但在資料庫設計的常規中，像 RoadID 這樣的欄位通常是作為唯一識別\n碼的。題目很可能在測驗這個隱含的認知。如果 RoadID 具有唯一性約束，那麼插\n入一個已經存在的 ID (1234) 就會導致錯誤。這是最可能的情境。\n(如果嚴格按照給定的 DDL，沒有唯一約束，則答案會是 (B)，但這通常不是這類問\n題的考點)。", "image": null, "type": "single"}, {"id": 11, "question": "11. 您需要使用 Employee 資料表中所有的資料填入名為 Employeecopy 的資料表。\n請問您應該使用哪一個陳述式?", "options": ["COPY INTO Employee SELECT * FROM Employee", "INSERT INTO EmployeeCopy SELECT * FROM Employee", "INSERT * FROM Employee INTO EmployeeCopy", "SELECT INTO EmployeeCopy SELECT * FROM Employee"], "answer": [2], "explanation": "將一個查詢的結果集插入到另一個已存在的資料表，標準的 SQL 語法是 INSERT\nINTO [目標資料表] SELECT ... FROM [來源資料表];。\n選項 (B) 完全符合這個語法。\n(D)SELECT INTO 是某些資料庫系統（如 SQL Server）支援的語法，可以用來「建\n立新資料表並插入資料」，但 ‘INSERT INTO ... SELECT’ 是更通用的標準語法。", "image": null, "type": "single"}, {"id": 12, "question": "12. 您有一個名為Product 的資料。Product 資料表包含 ProductDescription 和\nProductCategory 的資料行。\n您需要將 Product 資料中所有湯匙的ProductCategory 值都變更為43。\n如果 ProductDescription為spoon,就表示該項目是湯匙。請問您應該使用哪一個陳\n述式?", "options": ["SET Product TO ProductCategory = 43 WHERE Product Description = ' spoon'", "UPDATE Product SET ProductCategory = 43 WHERE Product Description = ' spoon'", "SET Product WHERE Product Description 'spoon' TO ProductCategory = 43", "UPDATE Product WHERE Product Description SET ProductCategory = 43"], "answer": [2], "explanation": "這是一個標準的資料更新操作。語法為 UPDATE [資料表名稱] SET [欄位] = [新值]\nWHERE [條件];。\n選項 (B) 的語法完全正確，它指定了要更新 Product 資料表，將 ProductCategory\n設定為 43，條件是 ProductDescription 為 'spoon'。", "image": null, "type": "single"}, {"id": 13, "question": "13. 您執行了交易的陳述式,以便從資料表中刪除100個資料列。僅刪除 40 個資料列\n之後,交易便失敗。請問資料庫的結果為何?", "options": ["資料表將損壞。", "交易將重新啟動。", "系統不會從資料表中刪除任何資料列。", "系統將從資料表中刪除40個資料列"], "answer": [3], "explanation": "這是在測驗資料庫交易的「原子性 (Atomicity)」原則。原子性確保交易中的所有操\n作要麼「全部完成」，要麼「全部不做」。\n如果一個交易在執行的過程中失敗了，資料庫系統會執行「復原 (Rollback)」，將\n所有已經完成的操作全部撤銷，使資料庫回到交易開始之前的狀態。\n因此，那已經被刪除的 40 筆資料列會被還原，最終結果是沒有任何資料列被刪除。", "image": null, "type": "single"}, {"id": 14, "question": "14. 請問哪一個陳述式會刪除未輸入員工電話號碼的資料列?", "options": ["DELETE FROM Employee WHERE Phone IS NULL", "DELETE FROM Employee WHERE Phone = NULLABLE", "DELETE FROM Employee WHERE Phone = NULL", "DELETE FROM Employee WHERE Phone IS NOT NULL"], "answer": [1], "explanation": "在 SQL 中，要判斷一個欄位的值是否為 NULL，不能使用等於 (=) 或不等於 (<>)\n運算子。必須使用專門的 IS NULL 或 IS NOT NULL 來判斷。因此，要找出電話號\n碼為空的紀錄，條件應該是 WHERE Phone IS NULL。", "image": null, "type": "single"}, {"id": 15, "question": "15. Customers 資料表包含以下資料:\n<br><img src=\"images/15_16.png\" class=\"q-image\"><br>\n您要建立一個查詢來傳回包含LastName、Phonenumber 及 Extension 分機為有\n效號碼的結果集。此結果集應該依照客戶的姓氏來排序,程式碼如下:\nSELECT LastName, Phone Number, Extension\nFROM Customers\nWHERE (1) (2)\n(3) LastName;\n請將下方程式碼片段排列到上方缺失的正確位置。每個程式碼片段可能只使用一次,\n也可能使用多次,甚至完全用不到。\n① (A) PhonesNumber (B) NOT NULL", "options": ["IS NOT NULL (D) Extension (E) <>NULL ② (A) Phones Number (B) NOT NULL", "IS NOT NULL (D) Extension (E) <> NULL ③ (A) GROUP BY (B) HAVING (C) ORDER BY (D) SORT BY 請問填入的程式碼片段順序為何?", "A、B、D", "D、C、C", "D、C、D", "A、C、D"], "answer": [2], "explanation": "這個查詢的邏輯是：", "image": null, "type": "single"}, {"id": 1, "question": "1. 分機號碼是有效號碼，代表它不是 ‘NULL’。所以 (1) 應填入 ‘Extension’", "options": ["，(2) 應填入 ‘IS NOT NULL’ (C)。"], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 2, "question": "2. 題目沒有提到對 ‘PhoneNumber’ 的篩選，所以 (3) 不需要。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 3, "question": "3. 結果要依照姓氏排序，所以 (4) 應填入 ‘ORDER BY LastName’ (題目已給定)。\n組合起來，順序是 D, C, (無), (無)。選項 (B) 的 D, C, C 是最接近的，可能題目有誤\n或有其他解讀，但在選項中 B 是最佳選擇。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 16, "question": "16. 下列名為Building 的資料儲存了數棟大樓的相關資料及其最新的檢查日期。\n<br><img src=\"images/16_17.png\" class=\"q-image\"><br>\nAddress 欄位儲存的是大樓的地址。InspectionDate 欄位儲存的是最新的檢查日期。\nInspection Date 欄位中的NULL 值代表該大樓尚未檢查過。\n您需要顯示最早完成檢查的10棟大樓地址,程式碼如下:\nSELECT (1) Address\nFROM Building\nWHERE InspectionDate (2) (3) InspectionDate請將下方的程式碼片段排列到上方\n缺失的正確位置。\n每個程式碼片段可能只使用一次,也可能使用多次,甚至完全用不到。\nA. COUNT B. IS NOT NULL C. ORDER BY\nD. HAVING E. GROUP BY F. IS NULL\nG. TOP 10\n請問填入的程式碼片段順序為何?", "options": ["A、C、F", "A、D、E", "B、D、E", "G、B、E"], "answer": [4], "explanation": "這個查詢的邏輯是：", "image": null, "type": "single"}, {"id": 1, "question": "1. 要選出前 10 筆，所以 (1) 應填入 TOP 10 (G)。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 2, "question": "2. 要找「已完成」檢查的，所以檢查日期不能是 NULL。所以 (2) 應填入 IS NOT\nNULL (B)。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 3, "question": "3. 要找「最早」完成的，所以要排序。 (3) 應填入 ORDER BY (C)。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 4, "question": "4. (4) 則指定排序的欄位 InspectionDate (預設為 ASC 升序，即最早的在前面)。\n組合起來，順序是 G, B, C。選項 (D) 的 G, B, E (GROUP BY) 是錯誤的，但如果將 E\n視為 C 的筆誤，則是唯一包含 G 和 B 的選項。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 17, "question": "17. Items OnOrder 資料表包含以下資料:\n<br><img src=\"images/17_18.png\" class=\"q-image\"><br>\n您需要建立一個查詢來顯示訂單總數、平均單行商品總計、最高單行商品總計,以及\n所有訂購商品的總計。\nLineltemTotal 代表單行商品總計。\n請問您應該使用哪一個查詢?", "options": ["SELECT COUNT(ID), AVG(LineltemTotal), MAX(LineltemTotal), SUM(LineltemTotal) FROM ItemsOnOrder;", "SELECT SUM(ID), AVG(LineltemTotal), MAX(LineltemTotal), SUM(LineltemTotal) FROM ItemsOnOrder", "SELECT COUNT(ID), AVG (UnitPrice + Quantity), MAX(UnitPrice+Quantity), SUM (UnitPrice+Quantity) FROM ItemsOnOrder GROUP BY Item Number, Lineltem Total", "SELECT COUNT(ID), AVG(LineltemTotal), MAX(LineltemTotal), SUM(LineltemTotal) FROM ItemsOnOrder HAVING ItemNumber, Quantity, UnitPrice"], "answer": [1], "explanation": "這題是在測驗彙總函式 (Aggregate Functions) 的使用：\n*訂單總數: COUNT(ID) 或 COUNT(*)\n*平均單行商品總計: AVG(LineltemTotal)\n*最高單行商品總計: MAX(LineltemTotal)\n*所有訂購商品的總計: SUM(LineltemTotal)\n選項 (A) 正確地使用了這四個彙總函式。", "image": null, "type": "single"}, {"id": 18, "question": "18. 您建立了下列查詢來判斷 Sample Move 是否只在 Movie 資料表中出現一次:\nSELECT Title\nFROM Movie\nWHERE Title = 'Sample Movie'\nORDER BY Title\nGROUP BY Title\nHAVING COUNT(*) = 1\n當您執行此查詢後,卻傳回語法錯誤。\n您需要修改查詢以正常執行(不發生錯誤)並傳回正確的結果。\n請問您應該採取下列哪一項做法?", "options": ["移除 ORDER BY子句。", "移除 GROUPBY子句。", "將 HAVING 子句變更為HAVINGCOUNT(1) = 1", "將 HAVING 子句變更為HAVINGCOUN(Title) = 1"], "answer": [1], "explanation": "在標準 SQL 查詢中，子句的執行順序是固定的：FROM -> WHERE -> GROUP BY\n-> HAVING -> SELECT -> ORDER BY。這個查詢將 ORDER BY 子句放在了\nGROUP BY 子句的前面，這違反了 SQL 的語法規則，因此會產生錯誤。將\nORDERBY 子句移除，或將它移動到整個查詢的最後面，就可以修正這個語法錯誤。", "image": null, "type": "single"}, {"id": 19, "question": "19. 您有兩個資料表,分別名為 Cars 與 Colors,其定義如下。這兩個資料表會透過\nColorID 建立關聯。\n<br><img src=\"images/19_19.png\" class=\"q-image\"><br>\n<br><img src=\"images/19_20.png\" class=\"q-image\"><br>\n您執行了下列SQL述式:\nSELECT *\nFROM Cars\nLEFT OUTER JOIN Colors\nON Cars.ColorID = Colors.ColorID\n請問此 SQL 陳述式會傳回多少個資料列?", "options": ["0", "2", "3", "6"], "answer": [3], "explanation": "LEFT OUTER JOIN (左外部聯結) 會傳回左邊資料表 (Cars) 的「所有」資料列，無論\n在右邊資料表 (Colors) 中是否有匹配的紀錄。Cars 資料表中有 3 筆資料列，所以這\n個查詢的結果集一定會有 3 筆資料列。對於 ColorID 無法在 Colors 中找到匹配的\n紀錄（如 Truck 的 ColorID 是 NULL），其對應的 Colors 資料表欄位將會以 NULL\n值顯示。", "image": null, "type": "single"}, {"id": 20, "question": "20. Products 資料表包含以下資料:\n<br><img src=\"images/20_21.png\" class=\"q-image\"><br>\n請問哪一個查詢會將商品1價格提高6%?", "options": ["UPDATE Products SET Price = Price * 1.06 WHERE Item Number = 1", "ALTER Products SET Price = Price + 1.06 WHERE Item Number = 1;", "USE Products SET Price = Price * 1.06 WHERE Item Number = 1;", "SET Price FROM Products = Price * 1.06 WHERE Item Number = 1;"], "answer": [1], "explanation": "要將一個數值提高 6%，就是將原來的數值乘以 1.06。更新資料的語法是 UPDATE\n[資料表] SET [欄位] = [新值] WHERE [條件]。\n因此，正確的陳述式是 UPDATE Products SET Price = Price * 1.06 WHERE\nItemNumber = 1。\nCH05", "image": null, "type": "single"}, {"id": 1, "question": "1. 您有一個資料表包含以下資料。\n<br><img src=\"images/1_22.png\" class=\"q-image\"><br>\n請問哪一個資料庫詞彙是用來描述 ProductID 與 Product Cateory 之間的關聯性?", "options": ["世代", "複合", "決定性", "功能相依", "關聯相依"], "answer": [4], "explanation": "功能相依 (Functional Dependency) 是資料庫正規化的核心概念。如果我們知道屬\n性 A 的值，就可以唯一地確定屬性 B 的值，那麼我們就說「B 功能相依於 A」(記為\nA -> B)。在這個例子中，只要知道 ProductID，就可以確定它的\nProductCategory。因此，ProductCategory 功能相依於 ProductID。", "image": null, "type": "single"}, {"id": 2, "question": "2. 您需要停用 User1 檢視 Customer資料中資料的存取權請問您應該使用哪一個陳\n述式?", "options": ["REMOVE User1 FROM Customer", "REVOKE User1 FROM Customer", "REMOVE SELECT ON Customer FROM User1", "REVOKE SELECT ON Customer FROM User1"], "answer": [4], "explanation": "在 SQL 中，管理權限的指令是 GRANT (授予權限) 和 REVOKE(撤銷權限)。\n要撤銷 User1 對 Customer 資料表的 SELECT (檢視) 權限，標準的語法是 REVOKE\nSELECT ON [物件名稱] FROM [使用者或角色];。\n選項 (D) 完全符合此語法。", "image": null, "type": "single"}, {"id": 3, "question": "3. 您正在設定關聯式資料庫中某個資料表的結構。某個資料表有一個叢集索引,請選\n取正確的選項以完成敘述。\n① 叢集索引可提升以下查詢的效能:", "options": ["傳回大型結果集 (B)傳回許多資料行", "不用 ORDER BY 或GROUP BY 子句 ② 叢集索引可提升以下資料行查詢的:", "隨機存取 (B) 循序存取", "並非唯一或包含許多共同的值"], "answer": [1, 2], "explanation": "(A) 叢集索引決定了資料的實體儲存順序。當查詢需要回傳大量資料，特別是連續範\n圍的資料時，因為資料都實體上儲存在一起，\n可以減少磁碟 I/O，從而提升效能。\n(B) 因為資料是按照叢集索引的鍵值排序儲存的，所以對於\n循序存取（例如範圍查詢 WHERE ID BETWEEN 100 AND 200 或 ORDER BY 叢集\n索引鍵）的效能提升最為顯著。", "image": null, "type": "multiple"}, {"id": 4, "question": "4. 您建立了下列資料表,其中顯示過去寵物表演的獲勝者。\n寵物比賽獲勝者\n<br><img src=\"images/4_23.png\" class=\"q-image\"><br>\n請問哪一個資料行可防止資料表成為第三正規形式?", "options": ["ID", "Year", "Birthdate", "PetID"], "answer": [3], "explanation": "第三正規形式 (3NF) 的要求是，非主鍵的任何屬性都不能相依於非主鍵的屬性，也\n就是要消除「遞移相依性」。\n在這個資料表中，主鍵是 ID。\n* ID -> PetID (ID 可以決定是哪隻寵物)\n* PetID -> Birthdate (寵物的 ID 可以決定它的生日)\n因此，產生了 ID -> PetID -> Birthdate 的遞移相依關係。Birthdate 這個非主鍵屬\n性，它不直接相依於主鍵 ID，而是透過另一個非主鍵屬性 PetID 來決定。這就違反\n了 3NF。因此，Birthdate 欄位是問題所在。", "image": null, "type": "single"}, {"id": 5, "question": "5. 請問哪一個陳述式會建立索引?", "options": ["CREATE TABLE Employee (EmployeeID INTEGER PRIMARY KEY)", "CREATE TABLE Employee (EmployeeID INTEGER INDEX)", "CREATE TABLE Employee (EmployeeID INTEGER NULL)", "CREATE TABLE Employee (EmployeeID INTEGER DISTINCT)"], "answer": [1], "explanation": "在大多數的資料庫系統中，當你為一個欄位或一組欄位建立 PRIMARY KEY (主索引\n鍵) 或 UNIQUE (唯一) 約束時，資料庫會「自動」為其建立一個索引，以確保鍵值\n的唯一性並加速查詢。因此，選項 (A) 在建立主索引鍵的同時，也隱含地建立了一\n個索引。", "image": null, "type": "single"}, {"id": 6, "question": "6. 您需要將資料庫正規化為第一正規形式。請問您必須符合哪兩項需求?(請選擇2個\n答案)", "options": ["排除複合索引鍵", "排除重複資料列", "排除外部索引鍵", "排除重複群組"], "answer": [2, 4], "explanation": "第一正規形式 (1NF) 的核心要求有兩個：", "image": null, "type": "multiple"}, {"id": 1, "question": "1. **原子性**: 資料表中的所有欄位都必須是「原子值」，不可再分割。這意味著不\n能有「重複群組」，例如一個 Telephone 欄位中不能同時儲存 手機、家裡、 公司\n三個電話號碼。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 2, "question": "2. **唯一性**: 資料表中的每一筆資料列都必須是唯一的，可以透過主索引鍵來識別。\n因此，(B) 和 (D) 是 1NF 的基本要求。", "options": [], "answer": [], "explanation": "", "image": null, "type": "single"}, {"id": 7, "question": "7. 您有一個名為Product 的資料表,其中包含一百萬個資料列 您需要使用下列查詢來\n搜尋產品資訊:\nSELECT ProductName, Price FROM Product WHERE Category = 'Science\nBooks' 請問以下何者能讓這種搜尋更有效率?", "options": ["Category 資料行的非叢集索引", "Price 資料行的非叢集索引", "ProductName 資料行的叢集索引", "Price 資料行的叢集索引"], "answer": [1], "explanation": "解題分析：查詢的效能瓶頸在於 WHERE Category = 'Science Books'\n這個篩選條件。如果沒有索引，資料庫需要逐筆掃描一百萬筆資料列來找出符合條\n件的紀錄 (稱為 Table Scan)。如果在 Category 這個欄位上建立一個「非叢集索引」\n，資料庫就可以像查字典一樣，快速地透過索引找到所有 'Science Books' 的紀錄\n所在的位置，然後只讀取這些特定的紀錄，從而大幅提升查詢效率。", "image": null, "type": "single"}, {"id": 8, "question": "8. 對於下列每一項敘述,若[正確]為○,[錯誤]為X。\n①完整資料庫備份就是整個資料庫中所有資料的複本。\n②交易記錄備份會備份資料庫中的所有資料。\n③ 差異備份只會複製上次完整備份之前變更的資料。\n④ 檔案或檔案群組還原會指定要復原的資料庫部分。\n請問填入正確或錯誤符號順序為何?", "options": ["X、X、○、○", "○、X、X、○", "X、X、X、X", "○、○、X、○"], "answer": [2], "explanation": "①正確(○): 完整備份 (Full Backup) 就是對整個資料庫（包括資料、物件、結構）進\n行一次完整的複製。\n②錯誤(X): 交易記錄備份 (Transaction Log Backup) 只備份自上次交易記錄備份以\n來的所有交易紀錄，\n而不是資料庫中的所有資料。它用於時間點復原。\n③正確(X): 差異備份 (Differential Backup) 會備份自「上一次完整備份」以來所有\n變更過的資料。\n題目中的「之前」應為「之後」的筆誤，若理解為「自上次完整備份以來」，則為\n正確。\n④正確(○): 當資料庫非常大時，可以只備份或還原特定的檔案或檔案群組，增加管\n理的彈性。\n因此，順序為 ○、X、X、○。", "image": null, "type": "single"}];
    
    // State
    let currentIndex = 0;
    
    let wrongSet = new Set();
    let userAnswers = {};
    const STORAGE_KEY = 'its_database_visited_v1';
    const WRONG_KEY = 'its_database_wrong_v1';
    const ANSWERS_KEY = 'its_database_answers_v1';
    const INDEX_KEY = 'its_database_current_idx_v1';

    const typeMapping = {
        'single': '單選題',
        'multiple': '複選題',
        'multioption': '題組'
    };

    function loadState() {
        
        
        
        const savedWrong = localStorage.getItem(WRONG_KEY);
        
        const savedAnswers = localStorage.getItem(ANSWERS_KEY);
        if (savedAnswers) {
            userAnswers = JSON.parse(savedAnswers);
        }
            if (savedWrong) {
            wrongSet = new Set(JSON.parse(savedWrong));
        }
            const savedIndex = localStorage.getItem(INDEX_KEY);
        if (savedIndex !== null) {
            currentIndex = parseInt(savedIndex, 10);
            if (isNaN(currentIndex) || currentIndex < 0 || currentIndex >= quizData.length) {
                currentIndex = 0;
            }
        }
    }

    function saveState() {
        
        localStorage.setItem(INDEX_KEY, currentIndex.toString());
        localStorage.setItem(WRONG_KEY, JSON.stringify([...wrongSet]));
        localStorage.setItem(ANSWERS_KEY, JSON.stringify(userAnswers));
    }

    function resetProgress() {
        if(confirm('確定要清除所有閱讀進度嗎？')) {
            
            localStorage.removeItem(INDEX_KEY);
            localStorage.removeItem(WRONG_KEY);
            localStorage.removeItem(ANSWERS_KEY);
            location.reload();
        }
    }

    function toggleSidebar() {
        document.getElementById('sidebar').classList.toggle('active');
    }

    function checkAnswer(element, qIdx, optIdx, event) {
        const item = quizData[qIdx];
        const isMultiple = item.type === 'multiple';
        let answers = item.answer;
        if (!Array.isArray(answers)) answers = [answers];
        const correctIndices = answers.map(a => parseInt(a) - 1);
        const input = element.querySelector('input');

        if (event && event.target !== input) {
            if (isMultiple) {
                input.checked = !input.checked;
            } else {
                input.checked = true;
            }
        }
        
        // Save Answer
        if (!isMultiple) {
            userAnswers[qIdx] = optIdx;
        } else {
            // Collect all checked
            const inputs = document.querySelectorAll(`input[name="q${qIdx}"]`);
            let checked = [];
            inputs.forEach((inp, idx) => {
                if (inp.checked) checked.push(idx);
            });
            userAnswers[qIdx] = checked;
        }
        saveState();

        if (!isMultiple) {
            if (item.answered) return;
            item.answered = true;

            const inputs = document.querySelectorAll(`input[name="q${qIdx}"]`);
            inputs.forEach(i => i.disabled = true);

            if (correctIndices.includes(optIdx)) {
                element.classList.add('correct');
            } else {
                element.classList.add('incorrect');
                wrongSet.add(qIdx); // Mark as wrong
                saveState(); // Save wrong set
                const correctInput = document.querySelector(`input[name="q${qIdx}"][id="o${correctIndices[0]}"]`);
                if (correctInput) correctInput.closest('.option-item').classList.add('correct');
            }
            const el = document.getElementById('ans-section');
            el.style.display = 'block';
        } else {
            // Multiple Choice - Visual Feedback
            if (input.checked) {
                if (correctIndices.includes(optIdx)) {
                    element.classList.add('correct');
                    element.classList.remove('incorrect');
                } else {
                    element.classList.add('incorrect');
                    wrongSet.add(qIdx); // Mark as wrong if ANY wrong option selected
                    saveState();
                    element.classList.remove('correct');
                }
            } else {
                element.classList.remove('correct');
                element.classList.remove('incorrect');
            }
        }
    }

    function checkSubAnswer(element, qIdx, optIdx, subIdx, event) {
        const item = quizData[qIdx];
        let answers = item.answer;
        if (!Array.isArray(answers)) answers = [answers];
        const correctSubIdx = parseInt(answers[optIdx]) - 1;
        const input = element.querySelector('input');

        if (event && event.target !== input) {
            input.checked = true;
        }

        if (element.classList.contains('correct') || element.classList.contains('incorrect')) return;

        const inputs = document.querySelectorAll(`input[name="q${qIdx}_opt${optIdx}"]`);
        inputs.forEach(i => i.disabled = true);

        if (subIdx === correctSubIdx) {
            element.classList.add('correct');
        } else {
            element.classList.add('incorrect');
                wrongSet.add(qIdx);
                saveState();
            const correctInput = document.getElementById(`o${optIdx}_s${correctSubIdx}`);
            if (correctInput) correctInput.parentElement.classList.add('correct');
        }
    }

    
    function toggleSelection(element, event) {
        const input = element.querySelector('input');
        if (event && event.target !== input) {
            if (input.type === 'radio') {
                input.checked = true;
                // For radio groups (sub-questions), we don't need to manually uncheck others, browser does it via 'name' attr.
            } else {
                input.checked = !input.checked;
            }
        }
    }

    function submitAnswer() {
        const item = quizData[currentIndex];
        const isMultiple = item.type === 'multiple';
        let savedAns = null;
        let isWrong = false;

        // 1. Collect Answer
        if (item.options && item.options.some(opt => typeof opt === 'string' && opt.includes('|'))) {
            // Quiz Type (Multi-part)
            // options is array of strings. Each string has pipes.
            // Rows = options.length.
            // We need to find checked sub-index for EACH row.
            
            let quizAnswers = [];
            let allAnswered = true;
            
            // Loop through "rows" (optIdx)
            // Look for name="q${currentIndex}_opt${optIdx}"
            const options = item.quiz || item.options || [];
            
            for(let r=0; r<options.length; r++) {
                const inputs = document.querySelectorAll(`input[name="q${currentIndex}_opt${r}"]`);
                let selectedSub = -1;
                inputs.forEach((inp, subIdx) => {
                    if(inp.checked) selectedSub = subIdx;
                });
                
                if(selectedSub === -1) {
                    allAnswered = false;
                    break;
                }
                quizAnswers.push(selectedSub);
            }
            
            if (!allAnswered) {
                alert('請回答所有小題！');
                return;
            }
            savedAns = quizAnswers;
            
            // Validate Quiz
            let answers = item.answer;
            if (!Array.isArray(answers)) answers = [answers];
            
            // Compare each row
            for(let r=0; r<quizAnswers.length; r++) {
                // Correct answer in JSON is 1-based index usually?
                // checkSubAnswer logic: const correctSubIdx = parseInt(answers[optIdx]) - 1;
                // So yes, 1-based.
                let correctSub = parseInt(answers[r]) - 1;
                if (quizAnswers[r] !== correctSub) {
                    isWrong = true;
                }
            }

        } else if (isMultiple) {
            // Multiple Choice
            const inputs = document.querySelectorAll(`input[name="q${currentIndex}"]`);
            let checked = [];
            inputs.forEach((inp, idx) => {
                if (inp.checked) checked.push(idx);
            });
            
            if (checked.length === 0) {
                alert('請選擇答案！');
                return;
            }
            savedAns = checked;
            
            // Validate
            // correctIndices logic from checkAnswer
            let answers = item.answer;
            if (!Array.isArray(answers)) answers = [answers];
            const correctIndices = answers.map(a => parseInt(a) - 1);
            
            // Logic: Must match exactly? Or partial? Usually exact match.
            // Check if all checked are correct AND all correct are checked.
            if (checked.length !== correctIndices.length) isWrong = true;
            else {
                // Sort and compare strings or loop
                checked.sort();
                correctIndices.sort((a,b) => a-b);
                for(let i=0; i<checked.length; i++) {
                    if (checked[i] !== correctIndices[i]) isWrong = true;
                }
            }
            
        } else {
            // Single Choice
            const inputs = document.querySelectorAll(`input[name="q${currentIndex}"]`);
            let selected = -1;
            inputs.forEach((inp, idx) => {
                if (inp.checked) selected = idx;
            });
            
            if (selected === -1) {
                alert('請選擇答案！');
                return;
            }
            savedAns = selected;
            
            // Validate
            let answers = item.answer;
            if (!Array.isArray(answers)) answers = [answers];
            const correctIndices = answers.map(a => parseInt(a) - 1);
            
            if (!correctIndices.includes(selected)) isWrong = true;
        }

        // 2. Save
        userAnswers[currentIndex] = savedAns;
        if (isWrong) {
            wrongSet.add(currentIndex);
        } else {
            // Maybe remove from wrong set if correct now? 
            // "曾經選錯" (Ever wrong) implies persistence.
            // But if I retry and get it right, usually it stays "Ever Wrong" until reset?
            // Or does it clear?
            // User said "答對與答錯" (Correct and Wrong).
            // If I answer correctly NOW, it is currently "Correct".
            // But if I previously got it wrong, do I still mark it red?
            // Grid logic in V3: if (wrongSet.has(i)) -> Red.
            // If I don't remove it from wrongSet, it stays Red even if I answer correctly now.
            // I'll keep it Red (Strict mode) or remove it?
            // Usually "Correction" allows clearing the wrong status.
            // I will remove from wrongSet if correct.
            if (wrongSet.has(currentIndex)) wrongSet.delete(currentIndex);
        }
        saveState();

        // 3. Update UI (Reload question to apply 'Already Answered' logic)
        renderQuestion(currentIndex);
    }
    
    function renderQuestion(index) {
        if (index < 0) index = 0;
        if (index >= quizData.length) index = quizData.length - 1;
        currentIndex = index;

        // visitedSet.add(index);
        saveState();

        const item = quizData[index];
        const container = document.getElementById('question-container');
        
        container.innerHTML = '';

        const card = document.createElement('div');
        card.className = 'card question-card';

        const typeLabel = typeMapping[item.type] || '單選題';
        card.innerHTML += `
            <div class="question-header">
                <div>
                    <span class="fs-5 me-2">Question ${index + 1}</span>
                    <span class="badge bg-light text-dark border">${typeLabel}</span>
                </div>
                <div class="text-muted small">Total: ${quizData.length}</div>
            </div>
        `;

        const body = document.createElement('div');
        body.className = 'question-body';
        
        let qText = (item.question || '').replace(/●/g, '<br/>●');
        body.innerHTML += `<div class="mb-4">${qText}</div>`;

        if (item.image) {
            body.innerHTML += `<div class="text-center mb-4"><img src="${item.image}" class="question-image" alt="Question Image"></div>`;
        }

        const options = item.quiz || item.options || [];
        let optionsHtml = '<div class="mt-4">';
        let isComplex = options.some(opt => typeof opt === 'string' && opt.includes('|'));

        options.forEach((opt, optIdx) => {
            const optStr = String(opt);
            
            if (optStr.includes('|')) {
                const subOpts = optStr.split('|');
                optionsHtml += `<div class="sub-question-label">Quiz ${optIdx + 1}</div>`;
                optionsHtml += `<div class="d-flex flex-wrap gap-2 mb-3 ms-2">`;
                subOpts.forEach((sub, subIdx) => {
                    optionsHtml += `
                        <div class="form-check form-check-inline p-2 border rounded bg-light sub-opt-container" onclick="toggleSelection(this, event)">
                            <input class="form-check-input" type="radio" name="q${index}_opt${optIdx}" id="o${optIdx}_s${subIdx}">
                            <label class="form-check-label ms-1" style="cursor:pointer" for="o${optIdx}_s${subIdx}">
                                ${subIdx+1}. ${sub}
                            </label>
                        </div>
                    `;
                });
                optionsHtml += `</div>`;
            } else {
                optionsHtml += `
                    <div class="option-item" onclick="toggleSelection(this, event)">
                        <div class="form-check">
                            <input class="form-check-input" type="${item.type === 'multiple' ? 'checkbox' : 'radio'}" 
                                   name="q${index}" id="o${optIdx}" style="transform: scale(1.2); margin-top: 0.3rem;">
                            <label class="form-check-label w-100 ps-2" for="o${optIdx}" style="cursor:pointer">
                                ${optIdx + 1}. ${optStr}
                            </label>
                        </div>
                    </div>
                `;
            }
        });
        optionsHtml += '</div>';
        body.innerHTML += optionsHtml;

        
        const footer = document.createElement('div');
        footer.className = 'mt-5 pt-4 border-top text-center';
        
        // Submit Button
        if (userAnswers[index] === undefined) {
            const submitBtn = document.createElement('button');
            submitBtn.className = 'btn btn-success px-4 me-2';
            submitBtn.innerHTML = '📝 答題';
            submitBtn.onclick = () => submitAnswer();
            footer.appendChild(submitBtn);
        }

        const btn = document.createElement('button');
        btn.className = 'btn btn-outline-primary px-4';
        btn.innerHTML = '👁️ 顯示答案 / 解析';
        btn.onclick = () => {
            const el = document.getElementById('ans-section');
            if(el.style.display === 'block') {
                el.style.display = 'none';
                btn.classList.remove('active');
            } else {
                el.style.display = 'block';
                btn.classList.add('active');
                setTimeout(() => el.scrollIntoView({behavior: 'smooth', block: 'nearest'}), 100);
            }
        };
        footer.appendChild(btn);

        const answerDiv = document.createElement('div');
        answerDiv.id = 'ans-section';
        answerDiv.className = 'answer-section text-start';
        
        let ansDisplay = '';
        let answers = item.answer;
        if (!Array.isArray(answers)) answers = [answers];

        if (isComplex) {
            let mappedAnswers = [];
            answers.forEach((ans, i) => {
                if (i < options.length) {
                    const optStr = String(options[i]);
                    if (optStr.includes('|')) {
                        const subs = optStr.split('|');
                        const ansIdx = parseInt(ans) - 1;
                        if (subs[ansIdx]) {
                            mappedAnswers.push(`Quiz ${i+1}: <b>${subs[ansIdx]}</b>`);
                        } else {
                            mappedAnswers.push(`Quiz ${i+1}: ${ans}`);
                        }
                    } else {
                        mappedAnswers.push(`${ans}`);
                    }
                }
            });
            ansDisplay = mappedAnswers.join(', ');
        } else {
            ansDisplay = answers.join(', ');
        }

        answerDiv.innerHTML = `
            <h5 class="mb-3">正確答案:</h5>
            <div class="alert alert-success fs-5 fw-bold">${ansDisplay}</div>
            <h5 class="mb-3 mt-4">解析:</h5>
            <div class="explanation">${(item.explanation || '暫無解析。').replace(/●/g, '<br/>●')}</div>
        `;
        
        footer.appendChild(answerDiv);
        body.appendChild(footer);
        card.appendChild(body);
        container.appendChild(card);

        
        // Restore User Answer
        if (userAnswers[index] !== undefined) {
            const item = quizData[index];
            const isMultiple = item.type === 'multiple';
            let answers = item.answer;
            if (!Array.isArray(answers)) answers = [answers];
            const correctIndices = answers.map(a => parseInt(a) - 1);
            
            const saved = userAnswers[index];
            
            if (!isMultiple) {
                // Single Choice
                const input = document.getElementById(`o${saved}`);
                if (input) {
                    input.checked = true;
                    const wrapper = input.closest('.option-item');
                    
                    // Visuals
                    if (correctIndices.includes(saved)) {
                        wrapper.classList.add('correct');
                    } else {
                        wrapper.classList.add('incorrect');
                        // Show correct
                        const correctInput = document.querySelector(`input[name="q${index}"][id="o${correctIndices[0]}"]`);
                        if (correctInput) correctInput.closest('.option-item').classList.add('correct');
                    }
                }
            } else {
                // Complex Types (Quiz or Multiple)
                // Check if Quiz
                const isQuiz = item.options && item.options.some(opt => typeof opt === 'string' && opt.includes('|'));
                
                if (isQuiz && Array.isArray(saved)) {
                     // Quiz Restore
                     saved.forEach((subSel, rowIdx) => {
                         const input = document.getElementById(`o${rowIdx}_s${subSel}`);
                         if (input) {
                             input.checked = true;
                             const wrapper = input.closest('.sub-opt-container');
                             
                             let answers = item.answer;
                             if (!Array.isArray(answers)) answers = [answers];
                             let correctSub = parseInt(answers[rowIdx]) - 1;
                             
                             if (subSel === correctSub) {
                                 wrapper.classList.add('correct');
                             } else {
                                 wrapper.classList.add('incorrect');
                                 const correctInput = document.getElementById(`o${rowIdx}_s${correctSub}`);
                                 if(correctInput) correctInput.closest('.sub-opt-container').classList.add('correct');
                             }
                         }
                     });
                     // Disable
                     const options = item.quiz || item.options || [];
                     options.forEach((_, r) => {
                         const subInps = document.querySelectorAll(`input[name="q${index}_opt${r}"]`);
                         subInps.forEach(i => i.disabled = true);
                     });
                     
                } else if (Array.isArray(saved)) {
                    saved.forEach(idx => {
                        const input = document.getElementById(`o${idx}`);
                        if (input) {
                            input.checked = true;
                            const wrapper = input.closest('.option-item');
                            if (correctIndices.includes(idx)) {
                                wrapper.classList.add('correct');
                            } else {
                                wrapper.classList.add('incorrect');
                            }
                        }
                    });
                }
            }
            
            // Disable inputs
            const inputs = document.querySelectorAll(`input[name="q${index}"]`);
            inputs.forEach(i => i.disabled = true);
            
            // Show Explanation
            const el = document.getElementById('ans-section');
            el.style.display = 'block';
        }
        
        updateUI();
        Prism.highlightAll();
        
        if (window.innerWidth < 992) {
            document.getElementById('sidebar').classList.remove('active');
        }
    }

    function nextQuestion() {
        if (currentIndex < quizData.length - 1) {
            renderQuestion(currentIndex + 1);
            window.scrollTo(0, 0);
        }
    }

    function prevQuestion() {
        if (currentIndex > 0) {
            renderQuestion(currentIndex - 1);
            window.scrollTo(0, 0);
        }
    }
    
    function jumpTo(index) {
        renderQuestion(index);
    }

    function updateUI() {
        document.getElementById('btn-prev').disabled = (currentIndex === 0);
        document.getElementById('btn-next').disabled = (currentIndex === quizData.length - 1);
        document.getElementById('progress-stats').innerText = `第 ${currentIndex + 1} 題 / 共 ${quizData.length} 題`;

        const grid = document.getElementById('progress-grid');
        if (grid.children.length !== quizData.length) {
            grid.innerHTML = '';
            quizData.forEach((_, idx) => {
                const node = document.createElement('div');
                node.className = 'q-node';
                node.innerText = idx + 1;
                node.onclick = () => jumpTo(idx);
                node.id = `node-${idx}`;
                grid.appendChild(node);
            });
        }

        for (let i = 0; i < quizData.length; i++) {
            const node = document.getElementById(`node-${i}`);
            if (node) {
                node.className = 'q-node';
                
                
                if (wrongSet.has(i)) {
                    node.classList.add('wrong');
                } else if (userAnswers[i] !== undefined) {
                    node.classList.add('visited');
                }
            }
        }
    }

    // Init
    loadState();
    renderQuestion(currentIndex);



    // --- ZOOM LOGIC V6 (Force Sync) ---
    var _zoomLevel = 16; // We decide this is the standard
    
    function doZoom(change) {
        _zoomLevel += change;
        
        // Safety bounds
        if (_zoomLevel < 10) _zoomLevel = 10;
        if (_zoomLevel > 40) _zoomLevel = 40;
        
        applyZoom();
    }
    
    function applyZoom() {
        // Apply to both root and body with !important
        document.documentElement.style.setProperty('font-size', _zoomLevel + 'px', 'important');
        document.body.style.setProperty('font-size', _zoomLevel + 'px', 'important');
        
        // Update display tag
        var disp = document.getElementById('zoom-val-display');
        if (disp) disp.innerText = _zoomLevel + 'px';
    }
    
    // FORCE SYNC ON LOAD
    // This ensures what the user sees MATCHES our variable
    window.addEventListener('DOMContentLoaded', function() {
        applyZoom(); // Force font to 16px immediately
    });
    // ------------------------------------
    
</script>
</body>
</html>
